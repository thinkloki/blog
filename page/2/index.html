<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>thinkloki</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="在路上">
<meta property="og:type" content="website">
<meta property="og:title" content="thinkloki">
<meta property="og:url" content="http://wait.im/page/2/index.html">
<meta property="og:site_name" content="thinkloki">
<meta property="og:description" content="在路上">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="thinkloki">
<meta name="twitter:description" content="在路上">
  
    <link rel="alternative" href="/atom.xml" title="thinkloki" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
  
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?548c9c362ce8ce4647fe98eaedd4e6e8";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://source.wait.im/QNbCS5A.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">thinkloki</a></h1>
		</hgroup>

		
		<p class="header-subtitle">做人不卖萌和咸鱼有什么区别</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/tags/随笔">随笔</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/thinkloki" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/u/2697700571" title="weibo">weibo</a>
					        
								<a class="mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=aVhRUFlYWl9ZKRgYRwoGBA" title="mail">mail</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Foundation/" style="font-size: 10px;">Foundation</a> <a href="/tags/Google/" style="font-size: 10px;">Google</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/IOS/" style="font-size: 15px;">IOS</a> <a href="/tags/JAVA/" style="font-size: 17.5px;">JAVA</a> <a href="/tags/MAC-OS/" style="font-size: 10px;">MAC OS</a> <a href="/tags/Material-Design/" style="font-size: 12.5px;">Material Design</a> <a href="/tags/Objective-C/" style="font-size: 10px;">Objective-C</a> <a href="/tags/open/" style="font-size: 10px;">open</a> <a href="/tags/swift/" style="font-size: 10px;">swift</a> <a href="/tags/优化/" style="font-size: 10px;">优化</a> <a href="/tags/内存/" style="font-size: 15px;">内存</a> <a href="/tags/动画/" style="font-size: 10px;">动画</a> <a href="/tags/多线程/" style="font-size: 10px;">多线程</a> <a href="/tags/热点/" style="font-size: 10px;">热点</a> <a href="/tags/调试/" style="font-size: 10px;">调试</a> <a href="/tags/随笔/" style="font-size: 10px;">随笔</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://heisenbean.me">何老师</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://v2ex.com">V2EX</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com">GitHub</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.tuijiankan.com">向阳乔木</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://jumi.xyz/">聚米</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://imququ.com/">Jerry Qu</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">Android资深码农，Objective-C、swift、python、php入门，励志成为全栈。资深手艺人，电子竞技爱好者。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">thinkloki</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="http://source.wait.im/QNbCS5A.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">thinkloki</h1>
			</hgroup>
			
			<p class="header-subtitle">做人不卖萌和咸鱼有什么区别</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tags/随笔">随笔</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/thinkloki" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/u/2697700571" title="weibo">weibo</a>
			        
						<a class="mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=aVhRUFlYWl9ZKRgYRwoGBA" title="mail">mail</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-Android性能调优的技术点" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/01/12/Android性能调优的技术点/" class="article-date">
  	<time datetime="2015-01-12T04:23:36.000Z" itemprop="datePublished">2015-01-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/01/12/Android性能调优的技术点/">Android性能调优的技术点</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##要点</p>
<p>###使用异步</p>
<ul>
<li>保持 APP 的高度响应，不要在 UI 线程做耗时操作，多使用异步任务</li>
<li>使用线程时要做好线程控制；使用队列、线程池</li>
<li>谨慎使用糟糕的 AysncTask 、 Timer</li>
<li>警惕异步任务引起的内存泄露</li>
<li>应该异步任务分类，比如 HTTP ，图片下载，文件读写，每一类的异步任务维护一个任务队列，而不是每一个任务都开一个线程（ Volley 表示我一个可以搞定这些全部 <em>(:з」∠)</em>）</li>
<li>这些常用的任务应该做好优先级处理（一般 JSON 数据优先于图片等静态数据的请求）</li>
<li>一般异步任务应该开启一个 SingleAsyncTask ，保证一时只有一个线程在工作</li>
<li>HTTP 和图片下载尽量使用同一套网络请求</li>
<li>使用 MVP 模式规范大型 Activity 类的行为，避免异步任务造成的内存泄露</li>
<li>避免内存泄露</li>
</ul>
<p>###了解虚拟机内存回收机制</p>
<ul>
<li>频繁 GC 也会造成卡顿，避免不必要的内存开销</li>
<li>错误的引用姿♂势造成的内存泄露（啊~要泄了~）</li>
<li>常见的 Activity 泄露（单例、 Application 、后台线程、无限动画、静态引用）</li>
<li>Bitmap 泄露（ HoneyComb 这个问题之前压力好大）</li>
<li>尽量使用 IntentService 代替 Service ，前者会自动 StopItself</li>
<li>排查内存泄露问题的方法（我一直以来都是简单暴力的人肉 dump 检查大法）</li>
<li>使用 LeakCanary 自动检查 Activity 泄露问题</li>
<li>对内存负载要保持敏感（ Sharp ）</li>
<li>视图优化</li>
</ul>
<p>###布局优化、减少层次， Include Merge</p>
<ul>
<li>使用 ViewStub 避免不必要的 LayoutInflate ，使用 GONE 代替重复 LayoutInflate 同一个布局</li>
<li>避免过度绘制，应该减少不必要的布局背景；布局层次太深会造成过度绘制以及 Measure 、 Layout 等方法时间复杂度的指数增长</li>
<li>使用过渡动画，比如给图片的呈现加一个轻量的淡入效果会让视觉上变得流畅许多</li>
<li>避免过度的动画，不要让一个界面同时出现多出动画，比如 List 滚动时 Item 项要停止播放动画或者 GIF</li>
<li>复杂动画使用 SurfaceView 或 TextureView</li>
<li>尽量提供多套分辨率的图片，使用矢量图</li>
</ul>
<p>##Adapter 优化</p>
<ul>
<li>复用 convertView ，用 ViewHolder 代替频繁 findViewById</li>
<li>不要重复 setListener ，要使用 v.getId 来复用 Listener ，不然会创建一堆 Listener 导致频繁 GC</li>
<li>多布局要采用 MutilItemView ，而不是使用一个大布局然后动态控制需要现实的部分</li>
<li>不要在 getView 方法做做耗时的操作</li>
<li>快速滚动列表的时候，可以停止加载列表项的图片，停止列表项的动画，不要在这时候改变列表项的布局</li>
<li>尽量用 RecyclerView （增量 Notify 和 RecycledViewPool 带你飞）</li>
</ul>
<p>####代码优化</p>
<ul>
<li>算法优化，减少时间复杂度，参考一些经典的优化算法</li>
<li>尽量使用 int ，而不是 float 或者 double</li>
<li>尽量采用基本类型，避免无必要的自动装箱和拆箱，浪费时间和空间</li>
<li>选用合适的集合类（尽量以空间换时间）、选用 Android 家的 SparseArray,SparseBooleanArray 和 LongSparseArray</li>
<li>避免创建额外的对象（ StringBuilder ）</li>
<li>使用 SO 库完成一些比较独立的功能（高斯模糊）</li>
<li>预处理（提前操作）一些比较耗时的初始化工作统一放到启动图处理</li>
<li>懒加载（延迟处理）规避 Activity 的敏感生命周期</li>
<li>Log 工具类，要在编译时删掉调试代码，而不是在运行时通过判断条件规避</li>
<li>优先使用静态方法、公有方法还是公有方法？速度区别很大哦</li>
<li>类内部直接对成员变量进行操作，不要使用 getter/setter 方法，调用方法耗额外的时间</li>
<li>给内部类访问的外部类成员变量要声明称包内可访问，而不是私有，不然编译的时候还是会自动创建用于访问外部类成员变量的方法</li>
<li>遍历集合时，使用 i++代替 Iterator ，后者需要额外的对象操作，应在循环体内避免这种情况</li>
<li>如果一个基本类型或者 String 的值不会改变，尽量用 final static ，编译时会直接用变量的值替换变量，也就不需要在查询变量的值了</li>
</ul>
<p>##其他优化</p>
<ul>
<li>数据库优化：使用索引、使用异步线程</li>
<li>网络优化 …… 一堆优秀的轮子</li>
<li>避免过度使用依赖注入框架，大量的反射</li>
<li>不过过度设计 /抽象，多态看起来很有设计感，代价就是额外的代码、空间、时间</li>
<li>尽量不要开启多进程，进程的开销很大</li>
</ul>
<p>####APK 瘦身</p>
<ul>
<li>开启混淆</li>
<li>使用 zipalign 工具优化 APK</li>
<li>适当有损图片压缩、使用矢量图</li>
<li>删除项目中冗余的资源，之前写过一些删除没有 res 资源的脚本</li>
<li>动态加载模块化，项目拆分啊！</li>
</ul>
<p>####性能问题的排查方法</p>
<ul>
<li>GPU 条形图，没事开来看看淘宝</li>
<li>过度绘制颜色，嗯，不要一篇姨妈红就好</li>
<li>LeakCanary ，自动检测 Activity 泄露，挺好用的</li>
<li>TraceView （ Device Monitor ）， Systrace ，分析哪些代码占用的 CPU 时间太大，屡试不爽</li>
<li>Lint ，检查不合理的 res 资源</li>
<li>layoutopt （还是 optlayout ？），对当前布局提出优化建议，已被 lint 替代，但是还能用</li>
<li>HierarchyViewer ，查看手机当前界面的布局层次，布局优化时常用（只用于模拟器，真机上用要 ROOT ，不想 ROOT 加得使用 ViewServer ）</li>
<li>StrictMode ， UI 操作、网络操作等容易出现性能问题的地方，如果出现异常情况 StrictMode 会报警</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/优化/">优化</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/内存/">内存</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Leakcanary Square的一款Android:Java内存泄漏检测工具" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/11/25/Leakcanary Square的一款Android:Java内存泄漏检测工具/" class="article-date">
  	<time datetime="2014-11-24T16:14:36.000Z" itemprop="datePublished">2014-11-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/11/25/Leakcanary Square的一款Android:Java内存泄漏检测工具/">Leakcanary Square的一款Android/Java内存泄漏检测工具</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p><a href="https://github.com/square/leakcanary" target="_blank" rel="external">Github地址</a></p>
</blockquote>
<p>##git readme:</p>
<p>###中文翻译@Jacksgong</p>
<blockquote>
<p>一款Android与Java的内存检测库<br>“A small leak will sink a gret ship.” - Benjamin Franklin</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Jacksgong/leakcanary/master/assets/screenshot.png" alt=""></p>
<p>###I. 开始<br><code>build.gradle</code> 中的配置:</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="section">dependencies</span> &#123;</div><div class="line">   <span class="attribute">debugCompile</span> <span class="string">'com.squareup.leakcanary:leakcanary-android:1.3'</span></div><div class="line">   releaseCompile <span class="string">'com.squareup.leakcanary:leakcanary-android-no-op:1.3'</span></div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p><code>Application class</code>中的配置:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ExampleApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span> public void onCreate() &#123;</div><div class="line">    <span class="keyword">super</span>.onCreate();</div><div class="line">    <span class="type">LeakCanary</span>.install(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样就可以了! 在debug包中activity内存泄漏将会被监听到，并且将会自动显示一个通知(show a notification)。</p>
<p>###II. 为什么要使用LeakCanary?<br>好问题! 我们已经在 <a href="http://squ.re/leakcanary" target="_blank" rel="external">博客文章</a>中回答了这个问题。</p>
<p>###III. 应该怎么使用它呢？<br>使用<code>RefWatcher</code>来监听引用是否已经被GC:</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="type">RefWatcher</span> refWatcher = <span class="meta">&#123;...&#125;</span>;</div><div class="line">// <span class="type">We</span> expect schrodingerCat to be gone soon (<span class="keyword">or</span> <span class="keyword">not</span>), <span class="keyword">let</span>'s watch it.</div><div class="line">// 我们预测shcrodingerCat很快会销毁(也许不会)，这里监听了它.</div><div class="line">refWatcher.watch(schrodingerCat);</div></pre></td></tr></table></figure>
<p><code>LeakCanary.install()</code>会返回预设的<code>RefWatcher</code>，并且安装了一个<code>ActivityRefWatcher</code>来监听activity调用了<code>Activity.onDestroy()</code>以后的泄漏。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ExampleApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line"></div><div class="line">  public static <span class="type">RefWatcher</span> getRefWatcher(<span class="type">Context</span> context) &#123;</div><div class="line">    <span class="type">ExampleApplication</span> application = (<span class="type">ExampleApplication</span>) context.getApplicationContext();</div><div class="line">    <span class="keyword">return</span> application.refWatcher;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="type">RefWatcher</span> refWatcher;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span> public void onCreate() &#123;</div><div class="line">    <span class="keyword">super</span>.onCreate();</div><div class="line">    refWatcher = <span class="type">LeakCanary</span>.install(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你也可以使用<code>RefWatcher</code>来监听fragment的泄漏:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span> public void onDestroy() &#123;</div><div class="line">    <span class="keyword">super</span>.onDestroy();</div><div class="line">    <span class="type">RefWatcher</span> refWatcher = <span class="type">ExampleApplication</span>.getRefWatcher(getActivity());</div><div class="line">    refWatcher.watch(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>###IV. LeakCanary是如何工作的呢?</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">RefWatcher</span><span class="selector-class">.watch</span>()创建了一个<span class="selector-tag">KeyedWeakReference</span>到了监控的对象。</div><div class="line">之后，在后台线程，它检查引用是否已经被释放，如果没有它将促发一次<span class="selector-tag">GC</span>。</div><div class="line">如果引用依然没有被释放，它会导出<span class="selector-tag">heap</span>到存储在<span class="selector-tag">app</span>文件系统的<span class="selector-tag">a</span><span class="selector-class">.hprof</span>文件。</div><div class="line"><span class="selector-tag">HeapAnalyzerService</span>在单独的一个进程被启动，并且<span class="selector-tag">HeapAnalyzer</span>使用<span class="selector-tag">HAHA</span>来解析<span class="selector-tag">heap</span>。</div><div class="line"><span class="selector-tag">HeapAnalyzer</span>由于采用了单独的<span class="selector-tag">reference</span> <span class="selector-tag">key</span>，在<span class="selector-tag">heap</span> <span class="selector-tag">dump</span>中找到了<span class="selector-tag">KeyedWeakReference</span>并且定位到泄漏的引用。</div><div class="line"><span class="selector-tag">HeapAnalyzer</span>通过计算出到<span class="selector-tag">GC</span>根部最短路径的强引用来决定是否这里是泄漏了，并且建立导致泄漏的引用关系链。</div><div class="line">结果将传回在<span class="selector-tag">app</span>进程的<span class="selector-tag">DisplayLeakService</span>，并且显示泄漏通知。</div></pre></td></tr></table></figure>
<p>###V. 我应该如何拷贝leak trace呢？<br>可以在Logcat中看到leak trace:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="type">In</span> com.example.leakcanary:<span class="number">1.0</span>:<span class="number">1</span> com.example.leakcanary.<span class="type">MainActivity</span> has leaked:</div><div class="line">* <span class="type">GC</span> <span class="type">ROOT</span> thread java.lang.<span class="type">Thread</span>.&lt;<span class="type">Java</span> <span class="type">Local</span>&gt; (named <span class="symbol">'AsyncTask</span> #<span class="number">1</span>')</div><div class="line">* references com.example.leakcanary.<span class="type">MainActivity</span>$<span class="number">3.</span><span class="keyword">this</span>$<span class="number">0</span> (anonymous <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">AsyncTask</span>)</span></div><div class="line">* leaks com.example.leakcanary.<span class="type">MainActivity</span> instance</div><div class="line"></div><div class="line">* <span class="type">Reference</span> <span class="type">Key</span>: e71f3bf5-d786<span class="number">-4145</span><span class="number">-8539</span><span class="number">-584</span>afaecad1d</div><div class="line">* <span class="type">Device</span>: <span class="type">Genymotion</span> generic <span class="type">Google</span> <span class="type">Nexus</span> <span class="number">6</span> - <span class="number">5.1</span><span class="number">.0</span> - <span class="type">API</span> <span class="number">22</span> - <span class="number">1440</span>x2560 vbox86p</div><div class="line">* <span class="type">Android</span> <span class="type">Version</span>: <span class="number">5.1</span> <span class="type">API</span>: <span class="number">22</span></div></pre></td></tr></table></figure>
<p>也可以从action bar menu分享leak trace与heap dump文件。</p>
<p>###VI. 应该如何解决内存泄漏呢?<br>一旦拥有了leak trace，就可以分析出哪个路径中的引用不应该存在，然后分析出引用依然存在的原因。通常情况是注册的监听没有反注册，或者是<code>close()</code>方法没有调用，或者是一个未知的类((通常也是没有句柄的对象，就纯new出来执行了某方法)hold住了外部类的引用。如果你分析不出你代码中的问题，别放弃，可以在Stack Overflow question(使用<code>leakcanary</code> 标签)中创建相关问题。</p>
<p>###VII. 我的泄漏是因为执行Android SDK导致的！<br>随着时间的推移，已经有一些已知的由于Android SDK的执行导致的内存泄漏得到了作为生厂商AOSP的修复。当发生这样的内存泄漏的时候，其实我们作为应用开发者能做的很少。对于这样的问题，LeakCanary已经有内建了一个忽略已知Android SDK泄漏的列表: <a href="https://github.com/square/leakcanary/blob/master/library/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java" target="_blank" rel="external">AndroidExcludedRefs.java</a>。如果你发现了新的，请提供leak trace、reference key、设备版本与Android版来<a href="https://github.com/square/leakcanary/issues/new" target="_blank" rel="external">创建问题</a>，当然如果能够提供一个heap dump的文件连接更好。</p>
<p>这对于新发布的Android来说是特别重要的，你有机会能够帮助尽早发现新的内存泄漏，使整个Android社区受益。</p>
<p>开发版本的快照: <a href="https://oss.sonatype.org/content/repositories/snapshots/" target="_blank" rel="external">Sonatype’s snapshots repository</a>。</p>
<p>###VIII. 超出leak trace范围</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">通常leak <span class="keyword">trace</span>是不够的，还需要通过MAT或者YourKit来深挖heap dump，下面是你如何通过heap dump来找出泄漏:</div><div class="line">找到com.squareup.leakcanary.KeyedWeakReference所有的实例。</div><div class="line">对于每个实例，查看它的<span class="built_in">key</span>成员变量。</div><div class="line">找到包含与LeakCanary报出的reference <span class="built_in">key</span>相同<span class="built_in">key</span>成员变量的KeyedWeakReference。</div><div class="line">那么这个KeyedWeakReference中的reference成员变量，就是你泄漏了的对象。</div><div class="line">到此为止，剩余的工作就是，开始查找到GC Roots最短路径(不包含弱引用)。</div></pre></td></tr></table></figure>
<p>###IX. 定制<br>图标与标注(Icon and Label)</p>
<p>DisplayLeakActivity默认是使用默认的图标与标注，当然你可以通过在你的app中提供<code>R.drawable.__leak_canary_icon</code>与<code>R.string.__leak_canary_display_activity_label</code>来定制这个:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">res/</div><div class="line">  drawable-hdpi/</div><div class="line">    __leak_canary_icon<span class="selector-class">.png</span></div><div class="line">  drawable-mdpi/</div><div class="line">    __leak_canary_icon<span class="selector-class">.png</span></div><div class="line">  drawable-xhdpi/</div><div class="line">    __leak_canary_icon<span class="selector-class">.png</span></div><div class="line">  drawable-xxhdpi/</div><div class="line">    __leak_canary_icon<span class="selector-class">.png</span></div><div class="line">  drawable-xxxhdpi/</div><div class="line">    __leak_canary_icon.png</div></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span><span class="meta">?&gt;</span></span></div><div class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"__leak_canary_display_activity_label"</span>&gt;</span>MyLeaks<span class="tag">&lt;/<span class="name">string</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></div></pre></td></tr></table></figure>
<p>####存储leak traces</p>
<p><code>DisplayLeakActivity</code>最多在app目录中存储7个heap dumps与leak traces 文件。你可以通过在你的app中提供<code>R.integer.__leak_canary_max_stored_leaks</code>来定制这个:</p>
<p>####上传到服务器</p>
<p>可以通过修改默认的行为来上传leak trace与heap dump到指定的服务器。</p>
<p>创建一个你自己的<code>AbstractAnalysisResultService</code>。最简单的方法是在debug的app中继承<code>DefaultAnalysisResultService</code>:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">LeakUploadService</span> <span class="keyword">extends</span> <span class="title">DefaultAnalysisResultService</span> </span>&#123;</div><div class="line">  <span class="meta">@Override</span> <span class="keyword">protected</span> void afterDefaultHandling(<span class="type">HeapDump</span> heapDump, <span class="type">AnalysisResult</span> result, <span class="type">String</span> leakInfo) &#123;</div><div class="line">    <span class="keyword">if</span> (!result.leakFound || result.excludedLeak) &#123;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    myServer.uploadLeakBlocking(heapDump.heapDumpFile, leakInfo);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要确认发布的Application类使用无效的RefWatcher:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ExampleApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line"></div><div class="line">  public static <span class="type">RefWatcher</span> getRefWatcher(<span class="type">Context</span> context) &#123;</div><div class="line">    <span class="type">ExampleApplication</span> application = (<span class="type">ExampleApplication</span>) context.getApplicationContext();</div><div class="line">    <span class="keyword">return</span> application.refWatcher;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="type">RefWatcher</span> refWatcher;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span> public void onCreate() &#123;</div><div class="line">    <span class="keyword">super</span>.onCreate();</div><div class="line">    refWatcher = installLeakCanary();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">protected</span> <span class="type">RefWatcher</span> installLeakCanary() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">RefWatcher</span>.<span class="type">DISABLED</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在你debug的Application类中创建一个自定义的RefWatcher:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">DebugExampleApplication</span> <span class="keyword">extends</span> <span class="title">ExampleApplication</span> </span>&#123;</div><div class="line">  <span class="keyword">protected</span> <span class="type">RefWatcher</span> installLeakCanary() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">LeakCanary</span>.install(app, <span class="type">LeakUploadService</span>.<span class="keyword">class</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不要忘了在debug的manifest里面注册service:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span><span class="meta">?&gt;</span></span></div><div class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></div><div class="line">    &gt;</div><div class="line">  <span class="tag">&lt;<span class="name">application</span> <span class="attr">android:name</span>=<span class="string">"com.example.DebugExampleApplication"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">"com.example.LeakUploadService"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">application</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></div></pre></td></tr></table></figure>
<p>你也可以上传leak traces到Slack或者HipChat，<a href="https://gist.github.com/pyricau/06c2c486d24f5f85f7f0" target="_blank" rel="external">这里是一个例子</a></p>
<p><img src="https://raw.githubusercontent.com/Jacksgong/leakcanary/master/assets/icon_512.png" alt=""><br>LeakCanary名称是为了表达<a href="http://en.wiktionary.org/wiki/canary_in_a_coal_mine" target="_blank" rel="external">canary in a coal mine</a>，因为LeakCanary是通过提供危险预警，检测风险的哨兵，维护者@edenman提的建议!</p>
<p>###X. License</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Copyright 2015 Square, Inc.</div><div class="line"></div><div class="line">Licensed under the Apache License, Version 2.0 (the "License");</div><div class="line">you may not <span class="keyword">use</span> this <span class="keyword">file</span> <span class="keyword">except</span> <span class="keyword">in</span> compliance <span class="keyword">with</span> the License.</div><div class="line">You may obtain a copy <span class="keyword">of</span> the License <span class="keyword">at</span></div><div class="line"></div><div class="line">   <span class="keyword">http</span>://www.apache.org/licenses/LICENSE<span class="number">-2.0</span></div><div class="line"></div><div class="line">Unless <span class="keyword">required</span> <span class="keyword">by</span> applicable law <span class="keyword">or</span> agreed <span class="keyword">to</span> <span class="keyword">in</span> writing, software</div><div class="line"><span class="keyword">distributed</span> <span class="keyword">under</span> the License <span class="keyword">is</span> <span class="keyword">distributed</span> <span class="keyword">on</span> an <span class="string">"AS IS"</span> BASIS,</div><div class="line"><span class="keyword">WITHOUT</span> WARRANTIES <span class="keyword">OR</span> CONDITIONS <span class="keyword">OF</span> <span class="keyword">ANY</span> KIND, either express <span class="keyword">or</span> implied.</div><div class="line">See the License <span class="keyword">for</span> the specific <span class="keyword">language</span> governing permissions <span class="keyword">and</span></div><div class="line">limitations <span class="keyword">under</span> the License.</div></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/内存/">内存</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-SVG Android应用探究之路" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/06/21/SVG Android应用探究之路/" class="article-date">
  	<time datetime="2014-06-20T16:12:36.000Z" itemprop="datePublished">2014-06-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/06/21/SVG Android应用探究之路/">SVG Android应用探究之路</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#####优点:</p>
<ul>
<li>vector</li>
<li>在所有大小分辨率屏幕上完美显示</li>
<li>SVG图片更小</li>
<li>一张图片可以更具需求多次使用？(One picture is used some times for different permissions)</li>
<li>减少加载时间</li>
</ul>
<p>#####缺点:</p>
<p>图片只能按照比例缩放<br>不支持透明度？<br>svg文件还可以近一步优化，里面有一些不可取（The schedule needs to be simplified — the more vector elements, the the file more weighs. It is undesirable to use shades and luminescences as it in times increases the size of SVG-files）</p>
<p>####SVG 的探索来源于：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">No sooner said than done. So, under katom history <span class="keyword">of</span> introduction <span class="keyword">of</span> vector images </div><div class="line"><span class="keyword">in</span> one <span class="keyword">of</span> our applications. <span class="keyword">In</span> article we will impart experience also features <span class="keyword">of</span> </div><div class="line"><span class="keyword">use</span> <span class="keyword">of</span> vector images <span class="keyword">in</span> format SVG <span class="keyword">in</span> applications Android.</div></pre></td></tr></table></figure></p>
<p>####编辑器：Adobe Illustrator 、Inkscape work.</p>
<p>####Google “android svg”:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">projects on guglokode:</div><div class="line"><span class="selector-tag">code</span><span class="selector-class">.google</span><span class="selector-class">.com</span>/p/svg-android/</div><div class="line"><span class="selector-tag">code</span><span class="selector-class">.google</span><span class="selector-class">.com</span>/p/svg-android-<span class="number">2</span>/</div><div class="line">Detailed <span class="selector-tag">article</span> about use NDK:</div><div class="line">horribileru<span class="selector-class">.blogspot</span><span class="selector-class">.ru</span>/<span class="number">2011</span>/<span class="number">10</span>/android-imageview-svg<span class="selector-class">.html</span></div><div class="line">And some links to dead projects at different forums.</div></pre></td></tr></table></figure></p>
<p>####一、SVG-Android：</p>
<p>#####GitHub: <a href="https://github.com/search?utf8=✓&amp;q=SVG-Android" target="_blank" rel="external">https://github.com/search?utf8=✓&amp;q=SVG-Android</a><br>他们项目通过底层封装的接口方式：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SVG svg = SVGParser.getSVGFromResource(getResources(), R.raw.filename)<span class="comment">;</span></div><div class="line">Drawable drawable = svg.createPictureDrawable()<span class="comment">;</span></div><div class="line">imageView.setImageDrawable(drawable)<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>缺点: 只支持 SVG basic 1.1(不支持Inkspace编辑、只支持AdobeIllustrator编辑)</p>
<p>####二、 SVG-Android-2:</p>
<p>####URL: <a href="https://code.google.com/p/svg-android-2/wiki/Introduction" target="_blank" rel="external">https://code.google.com/p/svg-android-2/wiki/Introduction</a></p>
<p>#####第一个发现：SVG在包含 阴影的情况下大小会飙升：<br><img src="http://blog.dreamtobe.cn/img/svg-k-1.png" alt="ICON1"><br>izorbrazhenija with a shade and without: 118 KB vs 1 KB</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">解决方法：删除对应的阴影</div></pre></td></tr></table></figure>
<p>#####第二个发现：显示梯度颜色，不支持！</p>
<p>The problem with gradients has dared removal of superfluous tags from svg (it is described further in article). But basically, and with it it would be possible to live and in our simple images to replace a gradient with homogeneous pouring, if not other nuance — considerable load time of images.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">解决方法：用简单的图片代替</div></pre></td></tr></table></figure>
<p>后文(第三个发现)提到解决方法： After we have got rid of the given links, having edited code SVG in some images, the gradient began to be displayed correctly.<br><img src="http://blog.dreamtobe.cn/img/svg-k-2.png" alt="icon 2"><br>at the left — the black sky in the form of a gradient, on the right — a correct picture.</p>
<p>#####第三个发现：加载时间</p>
<p>根源：为什么SVG-Android-2这么耗时，</p>
<p>原因：SVGParser 解析Image XML file ，解析了两次，第一次 为第二次解析收集多余的属性。多余信息是：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="literal">that</span> the most interesting, — <span class="keyword">is</span> analyzed only attribute xlink:href which <span class="keyword">is</span> a</div><div class="line">semblance <span class="keyword">of</span> hyperlinks <span class="keyword">in</span> the <span class="built_in">document</span>. In our problem images just there were</div><div class="line">such links, <span class="keyword">and</span> they conducted anywhere.</div></pre></td></tr></table></figure>
<p>成果：耗时，加载35个SVG的图片(PNG 500px*500px)：从原8s 减少到 1.8-2s。</p>
<p>#####第四个发现：透明与颜色适配器</p>
<p>原因：库不是加载 典型的bitmapDrawable与pictureDrawable,并且源码中的setColorFilter、setAlpha方法都是空的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void setColorFilter(ColorFilter colorFilter) &#123;&#125;</div><div class="line">@Override</div><div class="line">public void setAlpha(int alpha) &#123;&#125;</div></pre></td></tr></table></figure>
<p>成果：在SVGHandler中发现一个Paint类型的fillPaint组件，如果能够在加载元素之前 创建colorFilter即可，略微调整SVGHandler加载SVG的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFilterColor</span><span class="params">(<span class="keyword">int</span> filterColor)</span> </span>&#123;</div><div class="line">    fillPaint.setColorFilter(<span class="keyword">new</span> PorterDuffColorFilter(filterColor, Mode.MULTIPLY));</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>接口调整为：</p>
<figure class="highlight fix"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">SVG svg </span>=<span class="string"> SVGParser.getSVGFromResource(getResources(), rawSvgId, filterColor);</span></div></pre></td></tr></table></figure>
<p>因此我们能够在多张图片上通过引用一张图片使用不同的阴影颜色（As a result we could receive some images of different shades from one picture.）</p>
<p>对于透明度，建议并不适用setAlpha去实现（实际上是可以的通过fillPaint）:</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Also <span class="keyword">it</span> is possible <span class="built_in">to</span> establish <span class="keyword">and</span> Alpha <span class="keyword">for</span> fillPaint, but <span class="keyword">in</span> games this property is required <span class="keyword">in</span> <span class="keyword">the</span> dynamic form (have pressed <span class="keyword">an</span> <span class="keyword">element</span> — has become translucent), <span class="keyword">and</span> podgruzhat <span class="keyword">each</span> <span class="built_in">time</span> <span class="keyword">the</span> <span class="built_in">new</span> image is inconvenient. Therefore this effect have replaced <span class="keyword">with</span> scaling (have pressed — <span class="keyword">the</span> <span class="keyword">element</span> has decreased).</div></pre></td></tr></table></figure>
<p>#####第五个发现：异常处理：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">java<span class="selector-class">.lang</span><span class="selector-class">.UnsupportedOperationException</span></div><div class="line">  at android<span class="selector-class">.view</span><span class="selector-class">.GLES20Canvas</span><span class="selector-class">.drawPicture</span>(GLES20Canvas<span class="selector-class">.java</span>:<span class="number">895</span>)</div><div class="line">  at android<span class="selector-class">.graphics</span><span class="selector-class">.drawable</span><span class="selector-class">.PictureDrawable</span><span class="selector-class">.draw</span>(PictureDrawable<span class="selector-class">.java</span>:<span class="number">73</span>)</div></pre></td></tr></table></figure>
<p>低版本不支持gpu(api &lt; 11)</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">setSoftwareLayerType</span><span class="params">(View view)</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">     view.setLayerType(View.LAYER_TYPE_SOFTWARE, <span class="keyword">null</span>);</div><div class="line">   &#125; <span class="keyword">catch</span> (NoSuchMethodError e) &#123;</div><div class="line">       <span class="comment">//Do nothing - this happens on API &lt; 11</span></div><div class="line">   &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>####使用SVG的项目：</p>
<p><a href="http://play.google.com/store/apps/details?id=com.whisperarts.kids.forms" target="_blank" rel="external">http://play.google.com/store/apps/details?id=com.whisperarts.kids.forms</a></p>
<blockquote>
<p>本文总结自：<a href="http://sysmagazine.com/posts/166093/" target="_blank" rel="external">http://sysmagazine.com/posts/166093/</a></p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/">JAVA</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Hexo上第一篇博文" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/03/02/Hexo上第一篇博文/" class="article-date">
  	<time datetime="2014-03-01T16:18:36.000Z" itemprop="datePublished">2014-03-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/03/02/Hexo上第一篇博文/">Hexo上的第一篇博文</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这是使用Hexo搭建的博客后写的第一篇博文，搭建的过程还算顺利，写代码也写了两年了，觉得去总结一下也挺好，以后会把自己平时遇到的一些问题总结出来，码农也要学会总结，去提高自己。</p>
<p><a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>，特别感谢Hexo，上面的介绍已经非常详细了，感觉比搜出来的一些博文稍微靠谱一点。Node.js装环境的时候遇到不少问题，Hexo官网上都有非常好的解决方案，言简意赅。还要感谢前辈们的总结，在建博客的时候对我的帮助也不少。加油！！！</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hexo/">Hexo</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Android清理内存" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2013/10/25/Android清理内存/" class="article-date">
  	<time datetime="2013-10-24T16:16:36.000Z" itemprop="datePublished">2013-10-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/10/25/Android清理内存/">Android清理内存</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Android内存清理，利用ActivityManager获取当前正在运行的进程，清理这些进程释放内存。</p>
<p>可以根据importance的不同来判断前台或后台RunningAppProcessInfo 里面的常量IMOPORTANCE就是上面所说的前台后台，其实IMOPORTANCE是表示这个app进程的重要性，因为系统回收时候，会根据IMOPORTANCE来回收进程的。具体可以去看文档。。</p>
<p>在配置文件中添加权限</p>
<uses-permission android:name="”android.permission.KILL_BACKGROUND_PROCESSES”/">

<p>内存清理代码以及获取系统内存和各个APP占用内存代码如下：</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by thinkloki on 2013/8/20.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemUtil</span> </span>&#123;</div><div class="line"> </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取可用内存</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> context</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> getAvailMemory(Context context) &#123;</div><div class="line">        ActivityManager am = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);</div><div class="line">        ActivityManager.MemoryInfo mi = <span class="keyword">new</span> ActivityManager.MemoryInfo();</div><div class="line">        am.getMemoryInfo(mi);</div><div class="line">        <span class="keyword">return</span> mi.availMem / (<span class="number">1024</span> * <span class="number">1024</span>);</div><div class="line"> </div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取总内存</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> context</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> getTotalMemory(Context context) &#123;</div><div class="line">        String str1 = <span class="string">"/proc/meminfo"</span>;<span class="comment">// 系统内存信息文件</span></div><div class="line">        String str2;</div><div class="line">        String[] arrayOfString;</div><div class="line">        <span class="keyword">long</span> initial_memory = <span class="number">0</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            FileReader localFileReader = <span class="keyword">new</span> FileReader(str1);</div><div class="line">            BufferedReader localBufferedReader = <span class="keyword">new</span> BufferedReader(</div><div class="line">                    localFileReader, <span class="number">8192</span>);</div><div class="line">            str2 = localBufferedReader.readLine();<span class="comment">// 读取meminfo第一行，系统总内存大小</span></div><div class="line">            arrayOfString = str2.split(<span class="string">"\\s+"</span>);</div><div class="line">            initial_memory = Integer.valueOf(arrayOfString[<span class="number">1</span>]).intValue() * <span class="number">1024</span>;<span class="comment">// 获得系统总内存，单位是KB，乘以1024转换为Byte</span></div><div class="line">            localBufferedReader.close();</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> initial_memory / (<span class="number">1024</span> * <span class="number">1024</span>);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line"><span class="comment">//    public static final int IMPORTANCE_BACKGROUND = 400//后台</span></div><div class="line"><span class="comment">//    public static final int IMPORTANCE_EMPTY = 500//空进程</span></div><div class="line"><span class="comment">//    public static final int IMPORTANCE_SERVICE = 300//在服务中</span></div><div class="line"><span class="comment">//    public static final int IMPORTANCE_VISIBLE = 200//在屏幕前端、获取不到焦点可理解为</span></div><div class="line"><span class="comment">//    public static final int IMPORTANCE_FOREGROUND = 100//在屏幕最前端、可获取到焦点 可理解为Activity生命周期的OnResume();</span></div><div class="line"> </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 清理内存</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> context</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void clearMemory(Context context) &#123;</div><div class="line">        ActivityManager activityManger = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);</div><div class="line">        <span class="keyword">List</span>&lt;ActivityManager.RunningAppProcessInfo&gt; <span class="keyword">list</span> = activityManger.getRunningAppProcesses();</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">list</span> != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">list</span>.size(); i++) &#123;</div><div class="line">                ActivityManager.RunningAppProcessInfo apinfo = <span class="keyword">list</span>.get(i);</div><div class="line">                String[] pkgList = apinfo.pkgList;</div><div class="line">                <span class="keyword">if</span> (apinfo.importance &gt; ActivityManager.RunningAppProcessInfo.IMPORTANCE_VISIBLE) &#123;</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pkgList.length; j++) &#123;</div><div class="line">                        <span class="comment">/**清理不可用的内容空间**/</span></div><div class="line">                        activityManger.killBackgroundProcesses(pkgList[j]);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取每个APP占用的内存</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> context</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void getEveryAppMemory(Context context) &#123;</div><div class="line">        ActivityManager am = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);</div><div class="line">        <span class="keyword">List</span>&lt;ActivityManager.RunningAppProcessInfo&gt; <span class="keyword">list</span> = am.getRunningAppProcesses();</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">list</span> != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">list</span>.size(); i++) &#123;</div><div class="line">                ActivityManager.RunningAppProcessInfo appinfo = <span class="keyword">list</span>.get(i);</div><div class="line">                <span class="keyword">int</span>[] myMempid = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;appinfo.pid&#125;;</div><div class="line">                Debug.MemoryInfo[] appMem = am.getProcessMemoryInfo(myMempid);</div><div class="line">                <span class="keyword">int</span> memSize = appMem[<span class="number">0</span>].dalvikPrivateDirty / <span class="number">1024</span>;</div><div class="line">                Log.e(<span class="string">"AppMemory"</span>, appinfo.processName + <span class="string">":"</span> + memSize);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 清理应用缓存</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> context</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void clearAppCache(Context context) &#123;</div><div class="line">        File[] dir = context.getCacheDir().listFiles();</div><div class="line">        <span class="keyword">if</span> (dir != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">for</span> (File f : dir) &#123;</div><div class="line">                f.delete();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</uses-permission>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/内存/">内存</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Android动画简单学习" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2013/10/21/Android动画简单学习/" class="article-date">
  	<time datetime="2013-10-20T16:16:36.000Z" itemprop="datePublished">2013-10-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/10/21/Android动画简单学习/">Android动画简单学习</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>再复杂的动画，都是简单动画的结合</p>
</blockquote>
<p>###I. Tween Animation(补间动画)<br>形式|备注<br>—|—<br>alpha    |渐变透明度<br>scale    |渐变尺寸<br>translate|画面位置移动<br>rotate|画面旋转</p>
<p>####实现方式<br>Animation配合AnimationUtils，结合xml中set</p>
<p>###II. Frame Animation(关键帧动画)</p>
<blockquote>
<p>顺序播放关键帧</p>
</blockquote>
<p>####实现方式</p>
<p>AnimationDrawable结合xml中定义animation-list标签</p>
<blockquote>
<p>AnimationDrawable本身无法监听动画状态</p>
</blockquote>
<p>###III. 对象属性动画</p>
<blockquote>
<p>Andorid 3.0加入(如果3.0以下想用使用，可以参考开源动画库: <a href="http://nineoldandroids.com/" target="_blank" rel="external">http://nineoldandroids.com/</a>)<br>基本概念: 可以对对象属性进行动画，不仅仅是View</p>
</blockquote>
<p>动画的默认帧率是一帧10ms(100帧/s(Android正常绘制60帧/s))</p>
<p>#####1. TimeInterpolator(时间插值器)</p>
<blockquote>
<p>根据时间流逝的百分比来计算出当前属性值改变的百分比</p>
</blockquote>
<p>######系统默认提供的</p>
<ul>
<li>LinearInterpolator: 线性插值器，匀速动画</li>
<li>AccelerateDecelerateInterpolator: 加速减速插值器，动画两头慢中间快</li>
<li>DecelerateInterpolator: 减速插值器，动画越来越慢</li>
<li>AccelerateInterpolator: 加速插值器，动画越来越快</li>
<li>…</li>
</ul>
<p>#####2. TypeEvaluator(类型估值算法)</p>
<blockquote>
<p>根据当前属性改变的百分比来计算改变后的属性值</p>
</blockquote>
<p>######系统默认提供的</p>
<ul>
<li>IntEvaluator: 针对整型属性</li>
<li>FloatEvaluator: 针对浮点型属性</li>
<li>ArgbEvaluator: 针对Color属性</li>
<li>…</li>
</ul>
<blockquote>
<p>TypeEvaluator与TimeInterpolator是实现非匀速动画的神器。</p>
</blockquote>
<p>####实现方式</p>
<p>TimeInterpolator与TypeEvaluator两者是配合使用的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinearInterpolator</span> <span class="keyword">implements</span> <span class="title">Interpolator</span> </span>&#123;</div><div class="line"></div><div class="line">    ...</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getInterpolation</span><span class="params">(<span class="keyword">float</span> input)</span> </span>&#123;</div><div class="line">        <span class="comment">// 返回时间流逝的百分比 input = (当前时间 - 开始时间)/ 总时间</span></div><div class="line">        <span class="keyword">return</span> input; <span class="comment">// 匀速</span></div><div class="line">        <span class="comment">//return input * input; //加速</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntEvaluator</span> <span class="keyword">implements</span> <span class="title">TypeEvaluator</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">evaluate</span><span class="params">(<span class="keyword">float</span> fraction, Integer startValue, Integer endValue)</span> </span>&#123;</div><div class="line">        <span class="comment">// 返回需要变化的整型</span></div><div class="line">        <span class="keyword">int</span> startInt = startValue;</div><div class="line">        <span class="comment">// fraction: LinearInterpolator返回的流逝百分比</span></div><div class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(startInt + fraction * (endValue - startInt));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>#####3. ObjectAnimator、ValueAnimator、AnimatorSet</p>
<blockquote>
<p>都可以直接在xml中定义 / 直接代码中实现，结合TimeInterpolator与TypeEvaluator，几乎可以实现所有想要的动画</p>
</blockquote>
<hr>
<p>###例子<br>以下例子来自: <a href="http://blog.csdn.net/singwhatiwanna/article/details/17639987" target="_blank" rel="external">Android动画进阶—使用开源动画库nineoldandroids</a>与<a href="http://blog.csdn.net/singwhatiwanna/article/details/17841165" target="_blank" rel="external">Android属性动画深入分析</a>：让你成为动画牛人</p>
<p>#####第二个参数PropertyName</p>
<blockquote>
<p>PropertyName: 如第一个例子的”translationY”</p>
<p>我们定义第一个例子中的myObject为target</p>
</blockquote>
<ol>
<li>如果Animator中已经提供初始值，就只需要target包含Property的set方法(如第一个例子中myObject需要包含<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">set</span>TranslationY(<span class="built_in">float</span>)</div><div class="line">```)</div><div class="line">2. 如果Animator中未提供初始值，除了需要<span class="built_in">set</span>方法，还需要包含Property的get方法(如地i一个例子中myObject需要包含</div></pre></td></tr></table></figure>
</li>
</ol>
<p>getTranslationY():float<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">3. 满足以上两条，就可以定义为Property</div><div class="line">&gt;如果View/某对象没有满足上面的条件，如果可以，未尝不可自己封装一层实现。</div></pre></td></tr></table></figure></p>
<p>// 默认时间内，移动其高度的距离<br>ObjectAnimator.ofFloat(myObject, “translationY”, -myObject.getHeight()).start();<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>//  不断循环3s内背景颜色从红色渐变到蓝色再到红色<br>ValueAnimator colorAnim = ObjectAnimator.ofInt(<br>                this, “backgroundColor”,<br>                /<em>Red</em>/0xFFFF8080,/<em>Blue</em>/0xFF8080FF);<br>colorAnim.setDuration(3000);<br>colorAnim.setEvaluator(new ArgbEvaluator());<br>colorAnim.setRepeatCount(ValueAnimator.INFINITE);<br>colorAnim.setRepeatMode(ValueAnimator.REVERSE);<br>colorAnim.start();<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>// 5s内同时对View旋转、平移、缩放、透明都进行了改变<br>AnimatorSet set = new AnimatorSet();<br>set.playTogether(<br>    ObjectAnimator.ofFloat(myView, “rotationX”, 0, 360),<br>    ObjectAnimator.ofFloat(myView, “rotationY”, 0, 180),<br>    ObjectAnimator.ofFloat(myView, “rotation”, 0, -90),<br>    ObjectAnimator.ofFloat(myView, “translationX”, 0, 90),<br>    ObjectAnimator.ofFloat(myView, “translationY”, 0, 90),<br>    ObjectAnimator.ofFloat(myView, “scaleX”, 1, 1.5f),<br>    ObjectAnimator.ofFloat(myView, “scaleY”, 1, 0.5f),<br>    ObjectAnimator.ofFloat(myView, “alpha”, 1, 0.25f, 1)<br>);<br>set.setDuration(5 * 1000).start();<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>// ValueAnimator的使用<br>// 5s内匀速修改target的宽度<br>private void performAnimate(final View target, final int start, final int end) {<br>    ValueAnimator valueAnimator = ValueAnimator.ofInt(1, 100);</p>
<pre><code>valueAnimator.addUpdateListener(new AnimatorUpdateListener() {

    //持有一个IntEvaluator对象，方便下面估值的时候使用
    private IntEvaluator mEvaluator = new IntEvaluator();

    @Override
    public void onAnimationUpdate(ValueAnimator animator) {
        //获得当前动画的进度值，整型，1-100之间
        int currentValue = (Integer)animator.getAnimatedValue();
        Log.d(TAG, &quot;current value: &quot; + currentValue);

        //计算当前进度占整个动画过程的比例，浮点型，0-1之间
        float fraction = currentValue / 100f;

        //直接调用整型估值器通过比例计算出宽度，然后再设给Button
        target.getLayoutParams().width = mEvaluator.evaluate(fraction, start, end);
        target.requestLayout();
    }
});

valueAnimator.setDuration(5000).start();
</code></pre><p>}<br>```</p>
<ul>
<li><a href="https://developer.android.com/intl/zh-cn/guide/topics/graphics/prop-animation.html" target="_blank" rel="external">Property Animation</a></li>
<li><a href="http://blog.csdn.net/singwhatiwanna/article/details/9270275" target="_blank" rel="external">android动画简介</a></li>
<li><a href="http://blog.csdn.net/singwhatiwanna/article/details/17639987" target="_blank" rel="external">Android动画进阶—使用开源动画库nineoldandroids</a></li>
<li><a href="http://blog.csdn.net/qingye_love/article/details/8859347" target="_blank" rel="external">Animation 之 Interpolator 插补器理解</a></li>
<li><a href="http://blog.csdn.net/singwhatiwanna/article/details/17841165" target="_blank" rel="external">Android属性动画深入分析：让你成为动画牛人</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/">JAVA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/动画/">动画</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-面对对象基础跟内部类" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2012/07/30/面对对象基础跟内部类/" class="article-date">
  	<time datetime="2012-07-29T16:18:36.000Z" itemprop="datePublished">2012-07-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2012/07/30/面对对象基础跟内部类/">面对对象基础跟内部类</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一、面对对象的三大特征：封装、继承、多态。</p>
<font color="#24130c" face="Arial, Helvetica, simsun, u5b8bu4f53">    <font size="3">抽象：</font></font><font size="3">把现实中需要处理的事物通过数据的方法表达出来就是抽象。将现实的东西编程计算机的模式。</font>

<font size="3"><font face="arial, courier new, courier, 宋体, monospace">    封装：</font>把事物的数据和方法用类的方式集合起来就是封装，封装的数据和方法通过继承来实现重用。</font>

<font size="3"><font face="arial, courier new, courier, 宋体, monospace">    多态：</font>同一个方法通过方法的重载实现不同的逻辑即多态。</font>

<p>二、面对对象软件开发的大体分为，面向对象的分析，面向对象的设计，面向对象的实现。</p>
<p>分析用户的需求，从问题中抽取对象模型，细化模型，设计类，包括类的属性和类间的相互关系。同时观察是否有可以直接引用的已有的类或部件；使用Java语言，在开发中引入测试，并完善整个解决方案。</p>
<p>三、类</p>
<p>class前的修饰符分为访问控制符和非访问控制符两类。访问控制符包括public和private。非访问控制符包括abstract和final。</p>
<p>final是最终类，是不能有子类的，abstract和final不能修饰同一个类，因为抽象类本身没有具体的对象，需要派生出子类后在创建子类的对象。而最终不可能有子类。</p>
<p>创建对象的格式：类名+对象名=new 构造方法（参数）；前面是类名，后面是构造方法。</p>
<p>构造方法（构造函数）没有返回类型，也不能用void，主要完成对对象的初始化工作，一般不能直接由编程直接调用，而是用new运算符来调用。</p>
<p>如果class前面用public修饰，则默认构造方法的前面也是public修饰符。类中有static修饰的域或方法，可用类名或对象名进行访问。否则只能用对象名访问。</p>
<p><span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';"><span style="white-space:pre;">    </span>内部类的总结：</span><span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';"></span></p>
<p><span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';">&nbsp;<span style="white-space:pre;">    </span></span><span style="line-height: 23px; font-family: 宋体; font-size: 10.5pt;">内部类是指在一个外部类的内部再定义一个类。内部类作为外部类的一个成员，并且依附于外部类而存在的。</span></p>
<p><span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';">&nbsp;<span style="white-space:pre;">    </span></span><span style="line-height: 23px; font-family: 宋体; font-size: 10.5pt;">内部类同时具有成员和类的特性（特性不冲突）。&nbsp;内部类的分类：</span></p>
<p><span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';">&nbsp;<span style="white-space:pre;">    </span></span><span style="line-height: 23px; font-family: 宋体; font-size: 10.5pt;">成员内部类、</span><span style="line-height: 23px; font-family: 宋体; font-size: 10.5pt;">局部内部类、</span><span style="line-height: 23px; font-family: 宋体; font-size: 10.5pt;">静态内部类、</span><span style="line-height: 23px; font-family: 宋体; font-size: 10.5pt;">匿名内部类（图形是要用到，必须掌握）。</span></p>
<p><span style="white-space:pre;">        </span>1.成员内部类</p>
<p>成员内部类是定义在一个类中的类，他将信息更好的封装于一个类中，定义成员内部类后在使用它时可将其当成外部类的成员来使用，但若要使用内部类中的成员则需要创建内部类的实例。</p>
<p><span style="white-space:pre;">    </span>成员内部类和外部类之间的访问权限。</p>
<p>在类里面定义的类称之为内部类（Inner Class），内部类是外部类的一个成员。</p>
<p>内部类必须创建外部类对象才能使用。而创建内部类对象时必须先创建一个外部类对象，通过一个外部类对象才能创建内部类对象。</p>
<p>外部类名.内部类名&nbsp;变量名&nbsp;=&nbsp;new&nbsp;外部类名().new&nbsp;内部类名();</p>
<pre class="prettyprint">

class&nbsp;Inner{
<font color="#333333">//static&nbsp;int&nbsp;inner_i&nbsp;=100;&nbsp;//</font><font face="宋体"><font color="#333333">内部类中不允</font>许定</font>义<font color="#0000ff">静态</font><font color="#0000ff">变量</font>
<font color="#333333">int&nbsp;j=100;//</font><font face="宋体"><font color="#333333">内部类中外部类的</font><font color="#0000ff">实例变量</font></font>可以共存
int&nbsp;inner_i=1;
void&nbsp;inner_f1()

{
&nbsp;&nbsp;&nbsp;&nbsp;        System.out.println(i);//<font face="宋体">外部类的变量如果和内部类的变量没有同名的，则可以直接用变量名访问外部类的变量</font>
&nbsp;&nbsp;&nbsp;&nbsp;        System.out.println(j);//<font face="宋体">在内部类中访问内部类自己的变量直接用变量名</font>
&nbsp;&nbsp;&nbsp;    &nbsp;    System.out.println(this.j);//<font face="宋体">也可以在内部类中用</font><font face="Arial">"this.</font><font face="宋体">变量名</font><font face="Arial">"</font><font face="宋体">来访问内部类变量</font>
&nbsp;&nbsp;&nbsp;&nbsp;        //<font face="宋体">访问外部类中与内部类同名的</font>实例变量可用<font face="Arial">"</font><font face="宋体">外部类名</font><font face="Arial">.this.</font><font face="宋体">变量名</font><font face="Arial">"</font><font face="宋体">。</font>
&nbsp;&nbsp;&nbsp;&nbsp;        System.out.println(k);//<font face="宋体">外部类的变量如果和内部类的变量没有同名的，则可以直接用变量名访问外部类的变量</font>
&nbsp;&nbsp;&nbsp;&nbsp;        outer_f1();
&nbsp;&nbsp;&nbsp;&nbsp;        outer_f2();
}
}
</pre>

<p>成员内部类的优点：</p>
<pre id="best-content-521589254" accuse="aContent" style="margin-top: 0px; margin-bottom: 10px; padding: 0px; font-family: arial, 'courier new', courier, 宋体, monospace; white-space: pre-wrap; word-wrap: break-word; line-height: 24px;">    ⑴ 内部类作为外部类的成员，可以访问外部类的私有成员或属性。（即使将外部类声明为PRIVATE，但是对于处于其内部的内部类还是可见的。）
⑵ 用内部类定义在外部类中不可访问的属性。这样就在外部类中实现了比外部类的private还要小的访问权限。
注意：内部类是一个编译时的概念，一旦编译成功，就会成为完全不同的两类。对于一个名为outer的外部类和其内部定义的名为inner的内部类。编译完成后出现outer.class和outer$inner.class两类。</pre><pre id="best-content-521589254" accuse="aContent" style="margin-top: 0px; margin-bottom: 10px; padding: 0px; font-family: arial, 'courier new', courier, 宋体, monospace; white-space: pre-wrap; word-wrap: break-word; line-height: 24px;"><span style="white-space:pre;">    </span>2.局部内部类</pre><pre id="best-content-521589254" accuse="aContent" style="margin-top: 0px; margin-bottom: 10px; padding: 0px; font-family: arial, 'courier new', courier, 宋体, monospace; white-space: pre-wrap; word-wrap: break-word; line-height: 24px;">

<span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';"><span style="white-space:pre;">    </span>在方法中定义的内部类称为局部内部类。与局部变量类似，在局部内部类前不加修饰符<font face="Times New Roman">public</font><font face="宋体">和</font><font face="Times New Roman">private</font><font face="宋体">，其范围为定义它的代码块。</font></span><span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';"></span>

<span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';"><span style="white-space:pre;">    </span>注意：局部内部类不仅可以访问外部类实例变量，还可以访问外部类的局部变量（但此时要求外部类的局部变量必须为<font face="Times New Roman">final</font><font face="宋体">）？？</font></span><span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';"></span>

<span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';"><span style="white-space:pre;">    </span>在类外不可直接生成局部内部类（保证局部内部类对外是不可见的）。</span><span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';"></span>

<span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';"><span style="white-space:pre;">    </span>要想使用局部内部类时需要生成对象，对象调用方法，在方法中才能调用其局部内部类。</span><span style="font-size: 10.5pt; font-family: Arial;"></span>
</pre><pre id="best-content-521589254" accuse="aContent" style="margin-top: 0px; margin-bottom: 10px; padding: 0px; white-space: pre-wrap; word-wrap: break-word;">    3.静态内部类</pre><pre id="best-content-521589254" accuse="aContent" style="margin-top: 0px; margin-bottom: 10px; padding: 0px; white-space: pre-wrap; word-wrap: break-word; line-height: 24px;">    用static修饰的内部类就是静态内部类，和内部类不同，其实力的创建不需要外部对象。它只能访问外部类的静态成员和静态方法，不能访问非静态成员，但却可以访问自身内部的非静态成员变量。</pre>

<p>静态内部类可以用public，protected，private修饰，静态内部类中可以定义静态成员或非静态成员。</p>
<font face="宋体">&nbsp; &nbsp;&nbsp;</font>生成（new）一个静态内部类不需要外部类成员：这是静态内部类和成员内部类的区别。静态内部类的对象可以直接生成：<br><pre id="best-content-521589254" accuse="aContent" style="margin-top: 0px; margin-bottom: 10px; padding: 0px; font-family: arial, 'courier new', courier, 宋体, monospace; white-space: pre-wrap; word-wrap: break-word; line-height: 24px;">    Outer.Inner in=new Outer.Inner()；<br>而不需要通过生成外部类对象来生成。这样实际上使静态内部类成为了一个顶级类。静态内部类不可用private来进行定义。</pre><pre id="best-content-521589254" accuse="aContent" style="margin-top: 0px; margin-bottom: 10px; padding: 0px; font-family: arial, 'courier new', courier, 宋体, monospace; white-space: pre-wrap; word-wrap: break-word;">    4.匿名内部类</pre><pre id="best-content-521589254" accuse="aContent" style="margin-top: 0px; margin-bottom: 10px; padding: 0px; font-family: arial, 'courier new', courier, 宋体, monospace; white-space: pre-wrap; word-wrap: break-word;"><pre id="best-content-521589254" accuse="aContent" style="margin-top: 0px; margin-bottom: 10px; padding: 0px; font-family: arial, 'courier new', courier, 宋体, monospace; white-space: pre-wrap; word-wrap: break-word; color: rgb(51, 51, 51);">    匿名内部类是一种特殊的局部内部类，它是通过匿名类实现接口。<br>IA被定义为接口。<br>IA I=new IA(){};<br>匿名内部类的特点：<br>1，一个类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的事先或是覆盖。其实就是一个匿名子类对象。<br>2，只是为了获得一个对象实例，不需要知道其实际类型。<br>3，类名没有意义，也就是不需要使用到。</pre><pre id="best-content-521589254" accuse="aContent" style="margin-top: 0px; margin-bottom: 10px; padding: 0px; font-family: arial, 'courier new', courier, 宋体, monospace; white-space: pre-wrap; word-wrap: break-word; color: rgb(51, 51, 51);"><span style="white-space:pre;">    </span>4， new  父类OR 接口名{}。<br></pre></pre><br><br><wbr><br><pre class="prettyprint"><br><br>interface Test //定义一个接口，接口中有方法。<br>{<br>&nbsp; &nbsp; &nbsp; &nbsp; void func();<br>}<br>class Outer<br>{<br>&nbsp; &nbsp; &nbsp; &nbsp; public void method()<br>&nbsp; &nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Test T=new Test()//new一个接口对象，然后调用接口中的func方法<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; public void func()<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {&nbsp; &nbsp; &nbsp;&nbsp;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;     }<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; };<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; T.func();//通过new的对象可以实现调用接口中的多个引用，但最终不超过三个。<br>&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp; &nbsp; &nbsp;<br>}<br>public class Demo {<br><br>&nbsp; &nbsp; &nbsp; &nbsp; public static void main(String[] args) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // TODO Auto-generated method stub<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; func(new Test()<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; public void func(){}<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; });<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; public static void func(Test in)<br>&nbsp; &nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in.func();<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>}<br></pre><span style="white-space:pre;">    </span>匿名内部类的一般好处是：是代码更加简洁，紧凑，但带来的是易读性下降。它<font color="#ff0000" style="font-family: Arial; line-height: 26px;">一般用在GUI编程中实现事件处理</font>等等。<div><span style="line-height: 23px; font-size: 10.5pt;"><span style="white-space: pre;">    </span>匿名内部类是唯一一种无构造方法类。</span><div><div><br><br><span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';">&nbsp; &nbsp; &nbsp;</span><span style="line-height: 23px; font-family: 宋体; font-size: 10.5pt;">匿名内部类在编译的时候由系统自动起名</span><font face="Times New Roman" style="line-height: 23px; font-size: 10.5pt;">Out$1.class</font><font face="宋体" style="line-height: 23px; font-family: 宋体; font-size: 10.5pt;">。</font>

<p><span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';">&nbsp; &nbsp; &nbsp;</span><span style="line-height: 23px; font-family: 宋体; font-size: 10.5pt;">如果一个对象编译时的类型是接口，那么其运行的类型为实现这个接口的类。因匿名内部类无构造方法，所以其使用范围非常的有限。 &nbsp;</span></p>
<p>一、面对对象的三大特征：封装、继承、多态。</p>
<font color="#24130c" face="Arial, Helvetica, simsun, u5b8bu4f53">    <font size="3">抽象：</font></font><font size="3">把现实中需要处理的事物通过数据的方法表达出来就是抽象。将现实的东西编程计算机的模式。</font>

<font size="3"><font face="arial, courier new, courier, 宋体, monospace">    封装：</font>把事物的数据和方法用类的方式集合起来就是封装，封装的数据和方法通过继承来实现重用。</font>

<font size="3"><font face="arial, courier new, courier, 宋体, monospace">    多态：</font>同一个方法通过方法的重载实现不同的逻辑即多态。</font>

<p>二、面对对象软件开发的大体分为，面向对象的分析，面向对象的设计，面向对象的实现。</p>
<p>分析用户的需求，从问题中抽取对象模型，细化模型，设计类，包括类的属性和类间的相互关系。同时观察是否有可以直接引用的已有的类或部件；使用Java语言，在开发中引入测试，并完善整个解决方案。</p>
<p>三、类</p>
<p>class前的修饰符分为访问控制符和非访问控制符两类。访问控制符包括public和private。非访问控制符包括abstract和final。</p>
<p>final是最终类，是不能有子类的，abstract和final不能修饰同一个类，因为抽象类本身没有具体的对象，需要派生出子类后在创建子类的对象。而最终不可能有子类。</p>
<p>创建对象的格式：类名+对象名=new 构造方法（参数）；前面是类名，后面是构造方法。</p>
<p>构造方法（构造函数）没有返回类型，也不能用void，主要完成对对象的初始化工作，一般不能直接由编程直接调用，而是用new运算符来调用。</p>
<p>如果class前面用public修饰，则默认构造方法的前面也是public修饰符。类中有static修饰的域或方法，可用类名或对象名进行访问。否则只能用对象名访问。</p>
<p><span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';"><span style="white-space:pre;">    </span>内部类的总结：</span><span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';"></span></p>
<p><span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';">&nbsp;<span style="white-space:pre;">    </span></span><span style="line-height: 23px; font-family: 宋体; font-size: 10.5pt;">内部类是指在一个外部类的内部再定义一个类。内部类作为外部类的一个成员，并且依附于外部类而存在的。</span></p>
<p><span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';">&nbsp;<span style="white-space:pre;">    </span></span><span style="line-height: 23px; font-family: 宋体; font-size: 10.5pt;">内部类同时具有成员和类的特性（特性不冲突）。&nbsp;内部类的分类：</span></p>
<p><span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';">&nbsp;<span style="white-space:pre;">    </span></span><span style="line-height: 23px; font-family: 宋体; font-size: 10.5pt;">成员内部类、</span><span style="line-height: 23px; font-family: 宋体; font-size: 10.5pt;">局部内部类、</span><span style="line-height: 23px; font-family: 宋体; font-size: 10.5pt;">静态内部类、</span><span style="line-height: 23px; font-family: 宋体; font-size: 10.5pt;">匿名内部类（图形是要用到，必须掌握）。</span></p>
<p><span style="white-space:pre;">        </span>1.成员内部类</p>
<p>成员内部类是定义在一个类中的类，他将信息更好的封装于一个类中，定义成员内部类后在使用它时可将其当成外部类的成员来使用，但若要使用内部类中的成员则需要创建内部类的实例。</p>
<p><span style="white-space:pre;">    </span>成员内部类和外部类之间的访问权限。</p>
<p>在类里面定义的类称之为内部类（Inner Class），内部类是外部类的一个成员。</p>
<p>内部类必须创建外部类对象才能使用。而创建内部类对象时必须先创建一个外部类对象，通过一个外部类对象才能创建内部类对象。</p>
<p>外部类名.内部类名&nbsp;变量名&nbsp;=&nbsp;new&nbsp;外部类名().new&nbsp;内部类名();</p>
<pre class="prettyprint">

class&nbsp;Inner{
<font color="#333333">//static&nbsp;int&nbsp;inner_i&nbsp;=100;&nbsp;//</font><font face="宋体"><font color="#333333">内部类中不允</font>许定</font>义<font color="#0000ff">静态</font><font color="#0000ff">变量</font>
<font color="#333333">int&nbsp;j=100;//</font><font face="宋体"><font color="#333333">内部类中外部类的</font><font color="#0000ff">实例变量</font></font>可以共存
int&nbsp;inner_i=1;
void&nbsp;inner_f1()

{
&nbsp;&nbsp;&nbsp;&nbsp;        System.out.println(i);//<font face="宋体">外部类的变量如果和内部类的变量没有同名的，则可以直接用变量名访问外部类的变量</font>
&nbsp;&nbsp;&nbsp;&nbsp;        System.out.println(j);//<font face="宋体">在内部类中访问内部类自己的变量直接用变量名</font>
&nbsp;&nbsp;&nbsp;    &nbsp;    System.out.println(this.j);//<font face="宋体">也可以在内部类中用</font><font face="Arial">"this.</font><font face="宋体">变量名</font><font face="Arial">"</font><font face="宋体">来访问内部类变量</font>
&nbsp;&nbsp;&nbsp;&nbsp;        //<font face="宋体">访问外部类中与内部类同名的</font>实例变量可用<font face="Arial">"</font><font face="宋体">外部类名</font><font face="Arial">.this.</font><font face="宋体">变量名</font><font face="Arial">"</font><font face="宋体">。</font>
&nbsp;&nbsp;&nbsp;&nbsp;        System.out.println(k);//<font face="宋体">外部类的变量如果和内部类的变量没有同名的，则可以直接用变量名访问外部类的变量</font>
&nbsp;&nbsp;&nbsp;&nbsp;        outer_f1();
&nbsp;&nbsp;&nbsp;&nbsp;        outer_f2();
}
}
</pre>

<p>成员内部类的优点：</p>
<pre id="best-content-521589254" accuse="aContent" style="margin-top: 0px; margin-bottom: 10px; padding: 0px; font-family: arial, 'courier new', courier, 宋体, monospace; white-space: pre-wrap; word-wrap: break-word; line-height: 24px;">    ⑴ 内部类作为外部类的成员，可以访问外部类的私有成员或属性。（即使将外部类声明为PRIVATE，但是对于处于其内部的内部类还是可见的。）
⑵ 用内部类定义在外部类中不可访问的属性。这样就在外部类中实现了比外部类的private还要小的访问权限。
注意：内部类是一个编译时的概念，一旦编译成功，就会成为完全不同的两类。对于一个名为outer的外部类和其内部定义的名为inner的内部类。编译完成后出现outer.class和outer$inner.class两类。</pre><pre id="best-content-521589254" accuse="aContent" style="margin-top: 0px; margin-bottom: 10px; padding: 0px; font-family: arial, 'courier new', courier, 宋体, monospace; white-space: pre-wrap; word-wrap: break-word; line-height: 24px;"><span style="white-space:pre;">    </span>2.局部内部类</pre><pre id="best-content-521589254" accuse="aContent" style="margin-top: 0px; margin-bottom: 10px; padding: 0px; font-family: arial, 'courier new', courier, 宋体, monospace; white-space: pre-wrap; word-wrap: break-word; line-height: 24px;">

<span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';"><span style="white-space:pre;">    </span>在方法中定义的内部类称为局部内部类。与局部变量类似，在局部内部类前不加修饰符<font face="Times New Roman">public</font><font face="宋体">和</font><font face="Times New Roman">private</font><font face="宋体">，其范围为定义它的代码块。</font></span><span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';"></span>

<span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';"><span style="white-space:pre;">    </span>注意：局部内部类不仅可以访问外部类实例变量，还可以访问外部类的局部变量（但此时要求外部类的局部变量必须为<font face="Times New Roman">final</font><font face="宋体">）？？</font></span><span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';"></span>

<span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';"><span style="white-space:pre;">    </span>在类外不可直接生成局部内部类（保证局部内部类对外是不可见的）。</span><span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';"></span>

<span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';"><span style="white-space:pre;">    </span>要想使用局部内部类时需要生成对象，对象调用方法，在方法中才能调用其局部内部类。</span><span style="font-size: 10.5pt; font-family: Arial;"></span>
</pre><pre id="best-content-521589254" accuse="aContent" style="margin-top: 0px; margin-bottom: 10px; padding: 0px; white-space: pre-wrap; word-wrap: break-word;">    3.静态内部类</pre><pre id="best-content-521589254" accuse="aContent" style="margin-top: 0px; margin-bottom: 10px; padding: 0px; white-space: pre-wrap; word-wrap: break-word; line-height: 24px;">    用static修饰的内部类就是静态内部类，和内部类不同，其实力的创建不需要外部对象。它只能访问外部类的静态成员和静态方法，不能访问非静态成员，但却可以访问自身内部的非静态成员变量。</pre>

<p>静态内部类可以用public，protected，private修饰，静态内部类中可以定义静态成员或非静态成员。</p>
<font face="宋体">&nbsp; &nbsp;&nbsp;</font>生成（new）一个静态内部类不需要外部类成员：这是静态内部类和成员内部类的区别。静态内部类的对象可以直接生成：<br><pre id="best-content-521589254" accuse="aContent" style="margin-top: 0px; margin-bottom: 10px; padding: 0px; font-family: arial, 'courier new', courier, 宋体, monospace; white-space: pre-wrap; word-wrap: break-word; line-height: 24px;">    Outer.Inner in=new Outer.Inner()；<br>而不需要通过生成外部类对象来生成。这样实际上使静态内部类成为了一个顶级类。静态内部类不可用private来进行定义。</pre><pre id="best-content-521589254" accuse="aContent" style="margin-top: 0px; margin-bottom: 10px; padding: 0px; font-family: arial, 'courier new', courier, 宋体, monospace; white-space: pre-wrap; word-wrap: break-word;">    4.匿名内部类</pre><pre id="best-content-521589254" accuse="aContent" style="margin-top: 0px; margin-bottom: 10px; padding: 0px; font-family: arial, 'courier new', courier, 宋体, monospace; white-space: pre-wrap; word-wrap: break-word;"><pre id="best-content-521589254" accuse="aContent" style="margin-top: 0px; margin-bottom: 10px; padding: 0px; font-family: arial, 'courier new', courier, 宋体, monospace; white-space: pre-wrap; word-wrap: break-word; color: rgb(51, 51, 51);">    匿名内部类是一种特殊的局部内部类，它是通过匿名类实现接口。<br>IA被定义为接口。<br>IA I=new IA(){};<br>匿名内部类的特点：<br>1，一个类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的事先或是覆盖。其实就是一个匿名子类对象。<br>2，只是为了获得一个对象实例，不需要知道其实际类型。<br>3，类名没有意义，也就是不需要使用到。</pre><pre id="best-content-521589254" accuse="aContent" style="margin-top: 0px; margin-bottom: 10px; padding: 0px; font-family: arial, 'courier new', courier, 宋体, monospace; white-space: pre-wrap; word-wrap: break-word; color: rgb(51, 51, 51);"><span style="white-space:pre;">    </span>4， new  父类OR 接口名{}。<br></pre></pre><br><br><wbr><br><pre class="prettyprint"><br><br>interface Test //定义一个接口，接口中有方法。<br>{<br>&nbsp; &nbsp; &nbsp; &nbsp; void func();<br>}<br>class Outer<br>{<br>&nbsp; &nbsp; &nbsp; &nbsp; public void method()<br>&nbsp; &nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Test T=new Test()//new一个接口对象，然后调用接口中的func方法<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; public void func()<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {&nbsp; &nbsp; &nbsp;&nbsp;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;     }<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; };<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; T.func();//通过new的对象可以实现调用接口中的多个引用，但最终不超过三个。<br>&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp; &nbsp; &nbsp;<br>}<br>public class Demo {<br><br>&nbsp; &nbsp; &nbsp; &nbsp; public static void main(String[] args) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // TODO Auto-generated method stub<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; func(new Test()<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; public void func(){}<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; });<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; public static void func(Test in)<br>&nbsp; &nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in.func();<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>}<br></pre><span style="white-space:pre;">    </span>匿名内部类的一般好处是：是代码更加简洁，紧凑，但带来的是易读性下降。它<font color="#ff0000" style="font-family: Arial; line-height: 26px;">一般用在GUI编程中实现事件处理</font>等等。<div><span style="line-height: 23px; font-size: 10.5pt;"><span style="white-space: pre;">    </span>匿名内部类是唯一一种无构造方法类。</span><div><div><br><br><span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';">&nbsp; &nbsp; &nbsp;</span><span style="line-height: 23px; font-family: 宋体; font-size: 10.5pt;">匿名内部类在编译的时候由系统自动起名</span><font face="Times New Roman" style="line-height: 23px; font-size: 10.5pt;">Out$1.class</font><font face="宋体" style="line-height: 23px; font-family: 宋体; font-size: 10.5pt;">。</font>

<p><span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';">&nbsp; &nbsp; &nbsp;</span><span style="line-height: 23px; font-family: 宋体; font-size: 10.5pt;">如果一个对象编译时的类型是接口，那么其运行的类型为实现这个接口的类。因匿名内部类无构造方法，所以其使用范围非常的有限。 &nbsp;</span></p>
</div></div></div></div></div></div>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/">JAVA</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-多线程线程通讯和生产者" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2012/07/30/多线程线程通讯和生产者/" class="article-date">
  	<time datetime="2012-07-29T16:18:36.000Z" itemprop="datePublished">2012-07-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2012/07/30/多线程线程通讯和生产者/">多线程线程通讯和生产者</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>线程间通讯——等待唤醒机制<br>1，wait()；是让线程处于冻结状态，被wait线程会被存储到线程池中。<br>2,notify()；唤醒线程池中的一个线程(任意)。<br>3,notifyAll()；唤醒线程池中的所有线程，让线程具备了执行资格。<br>使用时要注意使用在同步中，因为只有同步才会具有锁。<br>调用时需要明确对象，明确是哪个监视器。<br>任意对象可以调用的方法定义在Object里面。</p>
<p>锁可以是任意对象。<br>为什么这些操作线程方法要定义在Object类中：因为这些方法在操作同步中线程时，都必须要标识它们所操作线程特有的锁，<br>只有同一个锁上的被等待线程，可以被同一个锁上的notify唤醒。<br>不可以对不同锁中的线程进行唤醒。等待和唤醒必须是同一个锁。而锁的对象是任意的，所以可以被任意对象调用的方法定义在Object类中。<br>一、线程间通信：<br>class Res<br>{<br>private String name;<br>private String sex;<br>private boolean flag = false;</p>
<p>public synchronized void set(String name,String sex)<br>{<br>if(flag)<br>try{this.wait();}catch(Exception e){}<br>this.name = name;</p>
<p>this.sex = sex;<br>flag = true;<br>this.notify();<br>}<br>public synchronized void out()<br>{<br>if(!flag)<br>try{this.wait();}catch(Exception e){}<br>System.out.println(name+”……..”+sex);<br>flag = false;<br>this.notify();<br>}<br>}</p>
<p>class Input implements Runnable<br>{<br>private Res r ;<br>Input(Res r)<br>{<br>this.r = r;<br>}<br>public void run()<br>{<br>int x = 0;<br>while(true)<br>{<br>if(x==0)<br>r.set(“mike”,”man”);<br>else<br>r.set(“丽丽”,”女女女女女”);<br>x = (x+1)%2;<br>}<br>}<br>}</p>
<p>class Output implements Runnable<br>{<br>private Res r ;</p>
<p>Output(Res r)<br>{<br>this.r = r;<br>}<br>public void run()<br>{<br>while(true)<br>{<br>r.out();<br>}<br>}<br>}</p>
<p>class  InputOutputDemo2<br>{<br>public static void main(String[] args)<br>{<br>Res r = new Res();</p>
<p>new Thread(new Input(r)).start();<br>new Thread(new Output(r)).start();<br>/*<br>Input in = new Input(r);<br>Output out = new Output(r);</p>
<p>Thread t1 = new Thread(in);<br>Thread t2 = new Thread(out);</p>
<p>t1.start();<br>t2.start();<br>*/<br>}<br>}<br>二、线程间通信-生产者和消费者<br>全部wait，生产和消费者多次判断，用while循环，唤醒时需要唤醒两方的人，这时我们用this.notifyAll().<br>对于多生产者和多消费者。<br>为什么要定义while判断标记。<br>原因：让被唤醒的线程在判断一次标记。<br>定义notifyAll，因为需要唤醒对方线程，只用notify，会出现只唤醒本方线程的情况。导致程序中所有线程都等待。<br>class ProducerConsumerDemo<br>{<br>public static void main(String[] args)<br>{<br>Resource r = new Resource();</p>
<p>Producer pro = new Producer(r);<br>Consumer con = new Consumer(r);</p>
<p>Thread t1 = new Thread(pro);<br>Thread t2 = new Thread(pro);<br>Thread t3 = new Thread(con);<br>Thread t4 = new Thread(con);</p>
<p>t1.start();<br>t2.start();<br>t3.start();<br>t4.start();</p>
<p>}<br>}</p>
<p>/*<br>对于多个生产者和消费者。<br>为什么要定义while判断标记。<br>原因：让被唤醒的线程再一次判断标记。</p>
<p>为什么定义notifyAll，<br>因为需要唤醒对方线程。<br>因为只用notify，容易出现只唤醒本方线程的情况。导致程序中的所有线程都等待。</p>
<p>*/</p>
<p>class Resource<br>{<br>private String name;<br>private int count = 1;<br>private boolean flag = false;<br>//  t1    t2<br>public synchronized void set(String name)<br>{<br>while(flag)<br>try{this.wait();}catch(Exception e){}//t1(放弃资格)  t2(获取资格)<br>this.name = name+”–”+count++;</p>
<p>System.out.println(Thread.currentThread().getName()+”…生产者..”+this.name);<br>flag = true;<br>this.notifyAll();<br>}</p>
<p>//  t3   t4<br>public synchronized void out()<br>{<br>while(!flag)<br>try{wait();}catch(Exception e){}//t3(放弃资格) t4(放弃资格)<br>System.out.println(Thread.currentThread().getName()+”…消费者………”+this.name);<br>flag = false;<br>this.notifyAll();<br>}<br>}</p>
<p>class Producer implements Runnable<br>{<br>private Resource res;</p>
<p>Producer(Resource res)<br>{<br>this.res = res;<br>}<br>public void run()<br>{<br>while(true)<br>{<br>res.set(“+商品+”);<br>}<br>}<br>}</p>
<p>class Consumer implements Runnable<br>{<br>private Resource res;</p>
<p>Consumer(Resource res)<br>{<br>this.res = res;<br>}<br>public void run()<br>{<br>while(true)<br>{<br>res.out();<br>}<br>}<br>}<br>三、JDK1.5中提供多线程解决方案。<br>将同步Synchronized替换成现实的Lock操作。<br>将Object中的wait，notify notifyAll，替换了Condition对象。<br>该对象可以Lock锁 进行获取。<br>该示例中，实现了本方只唤醒对方操作。<br>生产者、消费者有什么替代方案？<br>答：1.5版本以后，它提供了显示的锁机制以及显示的锁对象的等待唤醒操作机制，同时对等待唤醒进行了封装。一个锁可以对象多个Condition对象。<br>import java.util.concurrent.locks.*;</p>
<p>class ProducerConsumerDemo2<br>{<br>public static void main(String[] args)<br>{<br>Resource r = new Resource();</p>
<p>Producer pro = new Producer(r);<br>Consumer con = new Consumer(r);</p>
<p>Thread t1 = new Thread(pro);<br>Thread t2 = new Thread(pro);<br>Thread t3 = new Thread(con);<br>Thread t4 = new Thread(con);</p>
<p>t1.start();<br>t2.start();<br>t3.start();<br>t4.start();</p>
<p>}<br>}</p>
<p>/*<br>JDK1.5 中提供了多线程升级解决方案。<br>将同步Synchronized替换成现实Lock操作。<br>将Object中的wait，notify notifyAll，替换了Condition对象。<br>该对象可以Lock锁 进行获取。<br>该示例中，实现了本方只唤醒对方操作。</p>
<p>Lock:替代了Synchronized<br>lock<br>unlock<br>newCondition()</p>
<p>Condition：替代了Object wait notify notifyAll<br>await();<br>signal();<br>signalAll();<br>*/<br>class Resource<br>{<br>private String name;<br>private int count = 1;<br>private boolean flag = false;<br>//  t1    t2<br>private Lock lock = new ReentrantLock();</p>
<p>private Condition condition_pro = lock.newCondition();<br>private Condition condition_con = lock.newCondition();</p>
<p>public  void set(String name)throws InterruptedException<br>{<br>lock.lock();<br>try<br>{<br>while(flag)<br>condition_pro.await();//t1,t2<br>this.name = name+”–”+count++;</p>
<p>System.out.println(Thread.currentThread().getName()+”…生产者..”+this.name);<br>flag = true;<br>condition_con.signal();<br>}<br>finally<br>{<br>lock.unlock();//释放锁的动作一定要执行。<br>}<br>}</p>
<p>//  t3   t4<br>public  void out()throws InterruptedException<br>{<br>lock.lock();<br>try<br>{<br>while(!flag)<br>condition_con.await();<br>System.out.println(Thread.currentThread().getName()+”…消费者………”+this.name);<br>flag = false;<br>condition_pro.signal();<br>}<br>finally<br>{<br>lock.unlock();<br>}</p>
<p>}<br>}</p>
<p>class Producer implements Runnable<br>{<br>private Resource res;</p>
<p>Producer(Resource res)<br>{<br>this.res = res;<br>}<br>public void run()<br>{<br>while(true)<br>{<br>try<br>{<br>res.set(“+商品+”);<br>}<br>catch (InterruptedException e)<br>{<br>}</p>
<p>}<br>}<br>}</p>
<p>class Consumer implements Runnable<br>{<br>private Resource res;</p>
<p>Consumer(Resource res)<br>{<br>this.res = res;<br>}<br>public void run()<br>{<br>while(true)<br>{<br>try<br>{<br>res.out();<br>}<br>catch (InterruptedException e)<br>{<br>}<br>}<br>}<br>}</p>
<p>四、停止线程<br>只有一种，run方法结束。<br>开启多线程运行，运行代码通常是循环结构。只要控制住循环，就可以让run方法结束，也就是线程结束。<br>特殊情况：<br>当线程处于了冻结状态。就不会读取到标记。那么线程就不会结束。<br>当没有指定的方式让冻结的线程恢复到运行状态是，这时需要对冻结进行清除。强制让线程恢复到运行状态中来。这样就可以操作标记让线程结束。<br>Thread类提供该方法 interrupt();<br>class StopThread implements Runnable<br>{<br>private boolean flag =true;<br>public  void run()<br>{<br>while(flag)<br>{</p>
<p>System.out.println(Thread.currentThread().getName()+”….run”);<br>}<br>}<br>public void changeFlag()<br>{<br>flag = false;<br>}<br>}</p>
<p>class  StopThreadDemo<br>{<br>public static void main(String[] args)<br>{<br>StopThread st = new StopThread();</p>
<p>Thread t1 = new Thread(st);<br>Thread t2 = new Thread(st);</p>
<p>t1.setDaemon(true);<br>t2.setDaemon(true);<br>t1.start();<br>t2.start();</p>
<p>int num = 0;</p>
<p>while(true)<br>{<br>if(num++ == 60)<br>{<br>//st.changeFlag();<br>//t1.interrupt();<br>//t2.interrupt();<br>break;<br>}<br>System.out.println(Thread.currentThread().getName()+”…….”+num);<br>}<br>System.out.println(“over”);<br>}<br>}<br>五、守护线程</p>
<p>后台进程和前台进程共同抢夺CPU的执行权。</p>
<p>在启动线程时调用，当正在运行的此案称都是守护线程时，java虚拟机退出。</p>
<p>六.Join方法</p>
<p>主线程在向下执行的时候，遇到了join的时候是要申请加入到运行中来（通常来讲就是要有限取得cpu的执行权）主线程的执行权就给了它，此时主线程执行就处于冻结状态，当join结束时，主线程才复活。</p>
<p>join（）：当需要临时加入一个线程时。</p>
<p>join的特点：</p>
<p>当A线程执行到B线程的join（）方法时。A就会等待，等B线程都执行完，A才会执行，join可以用来临时加入线程执行。</p>
<p>join可以用来临时加入线程执行。</p>
<p>优先级&amp;yield方法</p>
<p>线程默认的优先级是5（1—10级）</p>
<p>MAX_PRIORITY 线程具有的最高优先级。</p>
<p>MIN_PRIORITY 分配给线程的默认优先级。</p>
<p>NORM_PRIORITY 线程可以具有的最低优先级。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/">JAVA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多线程/">多线程</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 thinkloki
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>