<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="thinkloki" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="在路上">
<meta property="og:type" content="website">
<meta property="og:title" content="thinkloki">
<meta property="og:url" content="http://wait.im/page/4/index.html">
<meta property="og:site_name" content="thinkloki">
<meta property="og:description" content="在路上">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="thinkloki">
<meta name="twitter:description" content="在路上">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://wait.im/page/4/"/>





  <title> thinkloki </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">thinkloki</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle">做人不卖萌和咸鱼有什么区别</p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://wait.im/2013/10/21/Android动画简单学习/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="thinkloki">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://source.wait.im/QNbCS5A.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="thinkloki">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="thinkloki" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2013/10/21/Android动画简单学习/" itemprop="url">
                  Android动画简单学习
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2013-10-21T00:16:36+08:00">
                2013-10-21
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>再复杂的动画，都是简单动画的结合</p>
</blockquote>
<h3 id="I-Tween-Animation-补间动画"><a href="#I-Tween-Animation-补间动画" class="headerlink" title="I. Tween Animation(补间动画)"></a>I. Tween Animation(补间动画)</h3><table>
<thead>
<tr>
<th>形式</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>alpha</td>
<td>渐变透明度</td>
</tr>
<tr>
<td>scale</td>
<td>渐变尺寸</td>
</tr>
<tr>
<td>translate</td>
<td>画面位置移动</td>
</tr>
<tr>
<td>rotate</td>
<td>画面旋转</td>
</tr>
</tbody>
</table>
<h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><p>Animation配合AnimationUtils，结合xml中set</p>
<h3 id="II-Frame-Animation-关键帧动画"><a href="#II-Frame-Animation-关键帧动画" class="headerlink" title="II. Frame Animation(关键帧动画)"></a>II. Frame Animation(关键帧动画)</h3><blockquote>
<p>顺序播放关键帧</p>
</blockquote>
<h4 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h4><p>AnimationDrawable结合xml中定义animation-list标签</p>
<blockquote>
<p>AnimationDrawable本身无法监听动画状态</p>
</blockquote>
<h3 id="III-对象属性动画"><a href="#III-对象属性动画" class="headerlink" title="III. 对象属性动画"></a>III. 对象属性动画</h3><blockquote>
<p>Andorid 3.0加入(如果3.0以下想用使用，可以参考开源动画库: <a href="http://nineoldandroids.com/" target="_blank" rel="external">http://nineoldandroids.com/</a>)<br>基本概念: 可以对对象属性进行动画，不仅仅是View</p>
</blockquote>
<p>动画的默认帧率是一帧10ms(100帧/s(Android正常绘制60帧/s))</p>
<h5 id="1-TimeInterpolator-时间插值器"><a href="#1-TimeInterpolator-时间插值器" class="headerlink" title="1. TimeInterpolator(时间插值器)"></a>1. TimeInterpolator(时间插值器)</h5><blockquote>
<p>根据时间流逝的百分比来计算出当前属性值改变的百分比</p>
</blockquote>
<h6 id="系统默认提供的"><a href="#系统默认提供的" class="headerlink" title="系统默认提供的"></a>系统默认提供的</h6><ul>
<li>LinearInterpolator: 线性插值器，匀速动画</li>
<li>AccelerateDecelerateInterpolator: 加速减速插值器，动画两头慢中间快</li>
<li>DecelerateInterpolator: 减速插值器，动画越来越慢</li>
<li>AccelerateInterpolator: 加速插值器，动画越来越快</li>
<li>…</li>
</ul>
<h5 id="2-TypeEvaluator-类型估值算法"><a href="#2-TypeEvaluator-类型估值算法" class="headerlink" title="2. TypeEvaluator(类型估值算法)"></a>2. TypeEvaluator(类型估值算法)</h5><blockquote>
<p>根据当前属性改变的百分比来计算改变后的属性值</p>
</blockquote>
<h6 id="系统默认提供的-1"><a href="#系统默认提供的-1" class="headerlink" title="系统默认提供的"></a>系统默认提供的</h6><ul>
<li>IntEvaluator: 针对整型属性</li>
<li>FloatEvaluator: 针对浮点型属性</li>
<li>ArgbEvaluator: 针对Color属性</li>
<li>…</li>
</ul>
<blockquote>
<p>TypeEvaluator与TimeInterpolator是实现非匀速动画的神器。</p>
</blockquote>
<h4 id="实现方式-2"><a href="#实现方式-2" class="headerlink" title="实现方式"></a>实现方式</h4><p>TimeInterpolator与TypeEvaluator两者是配合使用的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinearInterpolator</span> <span class="keyword">implements</span> <span class="title">Interpolator</span> </span>&#123;</div><div class="line"></div><div class="line">    ...</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getInterpolation</span><span class="params">(<span class="keyword">float</span> input)</span> </span>&#123;</div><div class="line">        <span class="comment">// 返回时间流逝的百分比 input = (当前时间 - 开始时间)/ 总时间</span></div><div class="line">        <span class="keyword">return</span> input; <span class="comment">// 匀速</span></div><div class="line">        <span class="comment">//return input * input; //加速</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntEvaluator</span> <span class="keyword">implements</span> <span class="title">TypeEvaluator</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">evaluate</span><span class="params">(<span class="keyword">float</span> fraction, Integer startValue, Integer endValue)</span> </span>&#123;</div><div class="line">        <span class="comment">// 返回需要变化的整型</span></div><div class="line">        <span class="keyword">int</span> startInt = startValue;</div><div class="line">        <span class="comment">// fraction: LinearInterpolator返回的流逝百分比</span></div><div class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(startInt + fraction * (endValue - startInt));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="3-ObjectAnimator、ValueAnimator、AnimatorSet"><a href="#3-ObjectAnimator、ValueAnimator、AnimatorSet" class="headerlink" title="3. ObjectAnimator、ValueAnimator、AnimatorSet"></a>3. ObjectAnimator、ValueAnimator、AnimatorSet</h5><blockquote>
<p>都可以直接在xml中定义 / 直接代码中实现，结合TimeInterpolator与TypeEvaluator，几乎可以实现所有想要的动画</p>
</blockquote>
<hr>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>以下例子来自: <a href="http://blog.csdn.net/singwhatiwanna/article/details/17639987" target="_blank" rel="external">Android动画进阶—使用开源动画库nineoldandroids</a>与<a href="http://blog.csdn.net/singwhatiwanna/article/details/17841165" target="_blank" rel="external">Android属性动画深入分析</a>：让你成为动画牛人</p>
<h5 id="第二个参数PropertyName"><a href="#第二个参数PropertyName" class="headerlink" title="第二个参数PropertyName"></a>第二个参数PropertyName</h5><blockquote>
<p>PropertyName: 如第一个例子的”translationY”</p>
<p>我们定义第一个例子中的myObject为target</p>
</blockquote>
<ol>
<li>如果Animator中已经提供初始值，就只需要target包含Property的set方法(如第一个例子中myObject需要包含<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">set</span>TranslationY(<span class="built_in">float</span>)</div><div class="line">```)</div><div class="line">2. 如果Animator中未提供初始值，除了需要<span class="built_in">set</span>方法，还需要包含Property的get方法(如地i一个例子中myObject需要包含</div></pre></td></tr></table></figure>
</li>
</ol>
<p>getTranslationY():float<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">3. 满足以上两条，就可以定义为Property</div><div class="line">&gt;如果View/某对象没有满足上面的条件，如果可以，未尝不可自己封装一层实现。</div></pre></td></tr></table></figure></p>
<p>// 默认时间内，移动其高度的距离<br>ObjectAnimator.ofFloat(myObject, “translationY”, -myObject.getHeight()).start();<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>//  不断循环3s内背景颜色从红色渐变到蓝色再到红色<br>ValueAnimator colorAnim = ObjectAnimator.ofInt(<br>                this, “backgroundColor”,<br>                /<em>Red</em>/0xFFFF8080,/<em>Blue</em>/0xFF8080FF);<br>colorAnim.setDuration(3000);<br>colorAnim.setEvaluator(new ArgbEvaluator());<br>colorAnim.setRepeatCount(ValueAnimator.INFINITE);<br>colorAnim.setRepeatMode(ValueAnimator.REVERSE);<br>colorAnim.start();<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>// 5s内同时对View旋转、平移、缩放、透明都进行了改变<br>AnimatorSet set = new AnimatorSet();<br>set.playTogether(<br>    ObjectAnimator.ofFloat(myView, “rotationX”, 0, 360),<br>    ObjectAnimator.ofFloat(myView, “rotationY”, 0, 180),<br>    ObjectAnimator.ofFloat(myView, “rotation”, 0, -90),<br>    ObjectAnimator.ofFloat(myView, “translationX”, 0, 90),<br>    ObjectAnimator.ofFloat(myView, “translationY”, 0, 90),<br>    ObjectAnimator.ofFloat(myView, “scaleX”, 1, 1.5f),<br>    ObjectAnimator.ofFloat(myView, “scaleY”, 1, 0.5f),<br>    ObjectAnimator.ofFloat(myView, “alpha”, 1, 0.25f, 1)<br>);<br>set.setDuration(5 * 1000).start();<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>// ValueAnimator的使用<br>// 5s内匀速修改target的宽度<br>private void performAnimate(final View target, final int start, final int end) {<br>    ValueAnimator valueAnimator = ValueAnimator.ofInt(1, 100);</p>
<pre><code>valueAnimator.addUpdateListener(new AnimatorUpdateListener() {

    //持有一个IntEvaluator对象，方便下面估值的时候使用
    private IntEvaluator mEvaluator = new IntEvaluator();

    @Override
    public void onAnimationUpdate(ValueAnimator animator) {
        //获得当前动画的进度值，整型，1-100之间
        int currentValue = (Integer)animator.getAnimatedValue();
        Log.d(TAG, &quot;current value: &quot; + currentValue);

        //计算当前进度占整个动画过程的比例，浮点型，0-1之间
        float fraction = currentValue / 100f;

        //直接调用整型估值器通过比例计算出宽度，然后再设给Button
        target.getLayoutParams().width = mEvaluator.evaluate(fraction, start, end);
        target.requestLayout();
    }
});

valueAnimator.setDuration(5000).start();
</code></pre><p>}<br>```</p>
<ul>
<li><a href="https://developer.android.com/intl/zh-cn/guide/topics/graphics/prop-animation.html" target="_blank" rel="external">Property Animation</a></li>
<li><a href="http://blog.csdn.net/singwhatiwanna/article/details/9270275" target="_blank" rel="external">android动画简介</a></li>
<li><a href="http://blog.csdn.net/singwhatiwanna/article/details/17639987" target="_blank" rel="external">Android动画进阶—使用开源动画库nineoldandroids</a></li>
<li><a href="http://blog.csdn.net/qingye_love/article/details/8859347" target="_blank" rel="external">Animation 之 Interpolator 插补器理解</a></li>
<li><a href="http://blog.csdn.net/singwhatiwanna/article/details/17841165" target="_blank" rel="external">Android属性动画深入分析：让你成为动画牛人</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://wait.im/2012/07/30/多线程线程通讯和生产者/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="thinkloki">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://source.wait.im/QNbCS5A.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="thinkloki">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="thinkloki" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2012/07/30/多线程线程通讯和生产者/" itemprop="url">
                  多线程线程通讯和生产者
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2012-07-30T00:18:36+08:00">
                2012-07-30
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>线程间通讯——等待唤醒机制<br>1，wait()；是让线程处于冻结状态，被wait线程会被存储到线程池中。<br>2,notify()；唤醒线程池中的一个线程(任意)。<br>3,notifyAll()；唤醒线程池中的所有线程，让线程具备了执行资格。<br>使用时要注意使用在同步中，因为只有同步才会具有锁。<br>调用时需要明确对象，明确是哪个监视器。<br>任意对象可以调用的方法定义在Object里面。</p>
<p>锁可以是任意对象。<br>为什么这些操作线程方法要定义在Object类中：因为这些方法在操作同步中线程时，都必须要标识它们所操作线程特有的锁，<br>只有同一个锁上的被等待线程，可以被同一个锁上的notify唤醒。<br>不可以对不同锁中的线程进行唤醒。等待和唤醒必须是同一个锁。而锁的对象是任意的，所以可以被任意对象调用的方法定义在Object类中。<br>一、线程间通信：<br>class Res<br>{<br>private String name;<br>private String sex;<br>private boolean flag = false;</p>
<p>public synchronized void set(String name,String sex)<br>{<br>if(flag)<br>try{this.wait();}catch(Exception e){}<br>this.name = name;</p>
<p>this.sex = sex;<br>flag = true;<br>this.notify();<br>}<br>public synchronized void out()<br>{<br>if(!flag)<br>try{this.wait();}catch(Exception e){}<br>System.out.println(name+”……..”+sex);<br>flag = false;<br>this.notify();<br>}<br>}</p>
<p>class Input implements Runnable<br>{<br>private Res r ;<br>Input(Res r)<br>{<br>this.r = r;<br>}<br>public void run()<br>{<br>int x = 0;<br>while(true)<br>{<br>if(x==0)<br>r.set(“mike”,”man”);<br>else<br>r.set(“丽丽”,”女女女女女”);<br>x = (x+1)%2;<br>}<br>}<br>}</p>
<p>class Output implements Runnable<br>{<br>private Res r ;</p>
<p>Output(Res r)<br>{<br>this.r = r;<br>}<br>public void run()<br>{<br>while(true)<br>{<br>r.out();<br>}<br>}<br>}</p>
<p>class  InputOutputDemo2<br>{<br>public static void main(String[] args)<br>{<br>Res r = new Res();</p>
<p>new Thread(new Input(r)).start();<br>new Thread(new Output(r)).start();<br>/*<br>Input in = new Input(r);<br>Output out = new Output(r);</p>
<p>Thread t1 = new Thread(in);<br>Thread t2 = new Thread(out);</p>
<p>t1.start();<br>t2.start();<br>*/<br>}<br>}<br>二、线程间通信-生产者和消费者<br>全部wait，生产和消费者多次判断，用while循环，唤醒时需要唤醒两方的人，这时我们用this.notifyAll().<br>对于多生产者和多消费者。<br>为什么要定义while判断标记。<br>原因：让被唤醒的线程在判断一次标记。<br>定义notifyAll，因为需要唤醒对方线程，只用notify，会出现只唤醒本方线程的情况。导致程序中所有线程都等待。<br>class ProducerConsumerDemo<br>{<br>public static void main(String[] args)<br>{<br>Resource r = new Resource();</p>
<p>Producer pro = new Producer(r);<br>Consumer con = new Consumer(r);</p>
<p>Thread t1 = new Thread(pro);<br>Thread t2 = new Thread(pro);<br>Thread t3 = new Thread(con);<br>Thread t4 = new Thread(con);</p>
<p>t1.start();<br>t2.start();<br>t3.start();<br>t4.start();</p>
<p>}<br>}</p>
<p>/*<br>对于多个生产者和消费者。<br>为什么要定义while判断标记。<br>原因：让被唤醒的线程再一次判断标记。</p>
<p>为什么定义notifyAll，<br>因为需要唤醒对方线程。<br>因为只用notify，容易出现只唤醒本方线程的情况。导致程序中的所有线程都等待。</p>
<p>*/</p>
<p>class Resource<br>{<br>private String name;<br>private int count = 1;<br>private boolean flag = false;<br>//  t1    t2<br>public synchronized void set(String name)<br>{<br>while(flag)<br>try{this.wait();}catch(Exception e){}//t1(放弃资格)  t2(获取资格)<br>this.name = name+”–”+count++;</p>
<p>System.out.println(Thread.currentThread().getName()+”…生产者..”+this.name);<br>flag = true;<br>this.notifyAll();<br>}</p>
<p>//  t3   t4<br>public synchronized void out()<br>{<br>while(!flag)<br>try{wait();}catch(Exception e){}//t3(放弃资格) t4(放弃资格)<br>System.out.println(Thread.currentThread().getName()+”…消费者………”+this.name);<br>flag = false;<br>this.notifyAll();<br>}<br>}</p>
<p>class Producer implements Runnable<br>{<br>private Resource res;</p>
<p>Producer(Resource res)<br>{<br>this.res = res;<br>}<br>public void run()<br>{<br>while(true)<br>{<br>res.set(“+商品+”);<br>}<br>}<br>}</p>
<p>class Consumer implements Runnable<br>{<br>private Resource res;</p>
<p>Consumer(Resource res)<br>{<br>this.res = res;<br>}<br>public void run()<br>{<br>while(true)<br>{<br>res.out();<br>}<br>}<br>}<br>三、JDK1.5中提供多线程解决方案。<br>将同步Synchronized替换成现实的Lock操作。<br>将Object中的wait，notify notifyAll，替换了Condition对象。<br>该对象可以Lock锁 进行获取。<br>该示例中，实现了本方只唤醒对方操作。<br>生产者、消费者有什么替代方案？<br>答：1.5版本以后，它提供了显示的锁机制以及显示的锁对象的等待唤醒操作机制，同时对等待唤醒进行了封装。一个锁可以对象多个Condition对象。<br>import java.util.concurrent.locks.*;</p>
<p>class ProducerConsumerDemo2<br>{<br>public static void main(String[] args)<br>{<br>Resource r = new Resource();</p>
<p>Producer pro = new Producer(r);<br>Consumer con = new Consumer(r);</p>
<p>Thread t1 = new Thread(pro);<br>Thread t2 = new Thread(pro);<br>Thread t3 = new Thread(con);<br>Thread t4 = new Thread(con);</p>
<p>t1.start();<br>t2.start();<br>t3.start();<br>t4.start();</p>
<p>}<br>}</p>
<p>/*<br>JDK1.5 中提供了多线程升级解决方案。<br>将同步Synchronized替换成现实Lock操作。<br>将Object中的wait，notify notifyAll，替换了Condition对象。<br>该对象可以Lock锁 进行获取。<br>该示例中，实现了本方只唤醒对方操作。</p>
<p>Lock:替代了Synchronized<br>lock<br>unlock<br>newCondition()</p>
<p>Condition：替代了Object wait notify notifyAll<br>await();<br>signal();<br>signalAll();<br>*/<br>class Resource<br>{<br>private String name;<br>private int count = 1;<br>private boolean flag = false;<br>//  t1    t2<br>private Lock lock = new ReentrantLock();</p>
<p>private Condition condition_pro = lock.newCondition();<br>private Condition condition_con = lock.newCondition();</p>
<p>public  void set(String name)throws InterruptedException<br>{<br>lock.lock();<br>try<br>{<br>while(flag)<br>condition_pro.await();//t1,t2<br>this.name = name+”–”+count++;</p>
<p>System.out.println(Thread.currentThread().getName()+”…生产者..”+this.name);<br>flag = true;<br>condition_con.signal();<br>}<br>finally<br>{<br>lock.unlock();//释放锁的动作一定要执行。<br>}<br>}</p>
<p>//  t3   t4<br>public  void out()throws InterruptedException<br>{<br>lock.lock();<br>try<br>{<br>while(!flag)<br>condition_con.await();<br>System.out.println(Thread.currentThread().getName()+”…消费者………”+this.name);<br>flag = false;<br>condition_pro.signal();<br>}<br>finally<br>{<br>lock.unlock();<br>}</p>
<p>}<br>}</p>
<p>class Producer implements Runnable<br>{<br>private Resource res;</p>
<p>Producer(Resource res)<br>{<br>this.res = res;<br>}<br>public void run()<br>{<br>while(true)<br>{<br>try<br>{<br>res.set(“+商品+”);<br>}<br>catch (InterruptedException e)<br>{<br>}</p>
<p>}<br>}<br>}</p>
<p>class Consumer implements Runnable<br>{<br>private Resource res;</p>
<p>Consumer(Resource res)<br>{<br>this.res = res;<br>}<br>public void run()<br>{<br>while(true)<br>{<br>try<br>{<br>res.out();<br>}<br>catch (InterruptedException e)<br>{<br>}<br>}<br>}<br>}</p>
<p>四、停止线程<br>只有一种，run方法结束。<br>开启多线程运行，运行代码通常是循环结构。只要控制住循环，就可以让run方法结束，也就是线程结束。<br>特殊情况：<br>当线程处于了冻结状态。就不会读取到标记。那么线程就不会结束。<br>当没有指定的方式让冻结的线程恢复到运行状态是，这时需要对冻结进行清除。强制让线程恢复到运行状态中来。这样就可以操作标记让线程结束。<br>Thread类提供该方法 interrupt();<br>class StopThread implements Runnable<br>{<br>private boolean flag =true;<br>public  void run()<br>{<br>while(flag)<br>{</p>
<p>System.out.println(Thread.currentThread().getName()+”….run”);<br>}<br>}<br>public void changeFlag()<br>{<br>flag = false;<br>}<br>}</p>
<p>class  StopThreadDemo<br>{<br>public static void main(String[] args)<br>{<br>StopThread st = new StopThread();</p>
<p>Thread t1 = new Thread(st);<br>Thread t2 = new Thread(st);</p>
<p>t1.setDaemon(true);<br>t2.setDaemon(true);<br>t1.start();<br>t2.start();</p>
<p>int num = 0;</p>
<p>while(true)<br>{<br>if(num++ == 60)<br>{<br>//st.changeFlag();<br>//t1.interrupt();<br>//t2.interrupt();<br>break;<br>}<br>System.out.println(Thread.currentThread().getName()+”…….”+num);<br>}<br>System.out.println(“over”);<br>}<br>}<br>五、守护线程</p>
<p>后台进程和前台进程共同抢夺CPU的执行权。</p>
<p>在启动线程时调用，当正在运行的此案称都是守护线程时，java虚拟机退出。</p>
<p>六.Join方法</p>
<p>主线程在向下执行的时候，遇到了join的时候是要申请加入到运行中来（通常来讲就是要有限取得cpu的执行权）主线程的执行权就给了它，此时主线程执行就处于冻结状态，当join结束时，主线程才复活。</p>
<p>join（）：当需要临时加入一个线程时。</p>
<p>join的特点：</p>
<p>当A线程执行到B线程的join（）方法时。A就会等待，等B线程都执行完，A才会执行，join可以用来临时加入线程执行。</p>
<p>join可以用来临时加入线程执行。</p>
<p>优先级&amp;yield方法</p>
<p>线程默认的优先级是5（1—10级）</p>
<p>MAX_PRIORITY 线程具有的最高优先级。</p>
<p>MIN_PRIORITY 分配给线程的默认优先级。</p>
<p>NORM_PRIORITY 线程可以具有的最低优先级。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://wait.im/2012/07/30/面对对象基础跟内部类/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="thinkloki">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://source.wait.im/QNbCS5A.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="thinkloki">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="thinkloki" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2012/07/30/面对对象基础跟内部类/" itemprop="url">
                  面对对象基础跟内部类
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2012-07-30T00:18:36+08:00">
                2012-07-30
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一、面对对象的三大特征：封装、继承、多态。</p>
<font color="#24130c" face="Arial, Helvetica, simsun, u5b8bu4f53">    <font size="3">抽象：</font></font><font size="3">把现实中需要处理的事物通过数据的方法表达出来就是抽象。将现实的东西编程计算机的模式。</font>

<font size="3"><font face="arial, courier new, courier, 宋体, monospace">    封装：</font>把事物的数据和方法用类的方式集合起来就是封装，封装的数据和方法通过继承来实现重用。</font>

<font size="3"><font face="arial, courier new, courier, 宋体, monospace">    多态：</font>同一个方法通过方法的重载实现不同的逻辑即多态。</font>

<p>二、面对对象软件开发的大体分为，面向对象的分析，面向对象的设计，面向对象的实现。</p>
<p>分析用户的需求，从问题中抽取对象模型，细化模型，设计类，包括类的属性和类间的相互关系。同时观察是否有可以直接引用的已有的类或部件；使用Java语言，在开发中引入测试，并完善整个解决方案。</p>
<p>三、类</p>
<p>class前的修饰符分为访问控制符和非访问控制符两类。访问控制符包括public和private。非访问控制符包括abstract和final。</p>
<p>final是最终类，是不能有子类的，abstract和final不能修饰同一个类，因为抽象类本身没有具体的对象，需要派生出子类后在创建子类的对象。而最终不可能有子类。</p>
<p>创建对象的格式：类名+对象名=new 构造方法（参数）；前面是类名，后面是构造方法。</p>
<p>构造方法（构造函数）没有返回类型，也不能用void，主要完成对对象的初始化工作，一般不能直接由编程直接调用，而是用new运算符来调用。</p>
<p>如果class前面用public修饰，则默认构造方法的前面也是public修饰符。类中有static修饰的域或方法，可用类名或对象名进行访问。否则只能用对象名访问。</p>
<p><span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';"><span style="white-space:pre;">    </span>内部类的总结：</span><span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';"></span></p>
<p><span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';">&nbsp;<span style="white-space:pre;">    </span></span><span style="line-height: 23px; font-family: 宋体; font-size: 10.5pt;">内部类是指在一个外部类的内部再定义一个类。内部类作为外部类的一个成员，并且依附于外部类而存在的。</span></p>
<p><span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';">&nbsp;<span style="white-space:pre;">    </span></span><span style="line-height: 23px; font-family: 宋体; font-size: 10.5pt;">内部类同时具有成员和类的特性（特性不冲突）。&nbsp;内部类的分类：</span></p>
<p><span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';">&nbsp;<span style="white-space:pre;">    </span></span><span style="line-height: 23px; font-family: 宋体; font-size: 10.5pt;">成员内部类、</span><span style="line-height: 23px; font-family: 宋体; font-size: 10.5pt;">局部内部类、</span><span style="line-height: 23px; font-family: 宋体; font-size: 10.5pt;">静态内部类、</span><span style="line-height: 23px; font-family: 宋体; font-size: 10.5pt;">匿名内部类（图形是要用到，必须掌握）。</span></p>
<p><span style="white-space:pre;">        </span>1.成员内部类</p>
<p>成员内部类是定义在一个类中的类，他将信息更好的封装于一个类中，定义成员内部类后在使用它时可将其当成外部类的成员来使用，但若要使用内部类中的成员则需要创建内部类的实例。</p>
<p><span style="white-space:pre;">    </span>成员内部类和外部类之间的访问权限。</p>
<p>在类里面定义的类称之为内部类（Inner Class），内部类是外部类的一个成员。</p>
<p>内部类必须创建外部类对象才能使用。而创建内部类对象时必须先创建一个外部类对象，通过一个外部类对象才能创建内部类对象。</p>
<p>外部类名.内部类名&nbsp;变量名&nbsp;=&nbsp;new&nbsp;外部类名().new&nbsp;内部类名();</p>
<pre class="prettyprint">

class&nbsp;Inner{
<font color="#333333">//static&nbsp;int&nbsp;inner_i&nbsp;=100;&nbsp;//</font><font face="宋体"><font color="#333333">内部类中不允</font>许定</font>义<font color="#0000ff">静态</font><font color="#0000ff">变量</font>
<font color="#333333">int&nbsp;j=100;//</font><font face="宋体"><font color="#333333">内部类中外部类的</font><font color="#0000ff">实例变量</font></font>可以共存
int&nbsp;inner_i=1;
void&nbsp;inner_f1()

{
&nbsp;&nbsp;&nbsp;&nbsp;        System.out.println(i);//<font face="宋体">外部类的变量如果和内部类的变量没有同名的，则可以直接用变量名访问外部类的变量</font>
&nbsp;&nbsp;&nbsp;&nbsp;        System.out.println(j);//<font face="宋体">在内部类中访问内部类自己的变量直接用变量名</font>
&nbsp;&nbsp;&nbsp;    &nbsp;    System.out.println(this.j);//<font face="宋体">也可以在内部类中用</font><font face="Arial">"this.</font><font face="宋体">变量名</font><font face="Arial">"</font><font face="宋体">来访问内部类变量</font>
&nbsp;&nbsp;&nbsp;&nbsp;        //<font face="宋体">访问外部类中与内部类同名的</font>实例变量可用<font face="Arial">"</font><font face="宋体">外部类名</font><font face="Arial">.this.</font><font face="宋体">变量名</font><font face="Arial">"</font><font face="宋体">。</font>
&nbsp;&nbsp;&nbsp;&nbsp;        System.out.println(k);//<font face="宋体">外部类的变量如果和内部类的变量没有同名的，则可以直接用变量名访问外部类的变量</font>
&nbsp;&nbsp;&nbsp;&nbsp;        outer_f1();
&nbsp;&nbsp;&nbsp;&nbsp;        outer_f2();
}
}
</pre>

<p>成员内部类的优点：</p>
<pre id="best-content-521589254" accuse="aContent" style="margin-top: 0px; margin-bottom: 10px; padding: 0px; font-family: arial, 'courier new', courier, 宋体, monospace; white-space: pre-wrap; word-wrap: break-word; line-height: 24px;">    ⑴ 内部类作为外部类的成员，可以访问外部类的私有成员或属性。（即使将外部类声明为PRIVATE，但是对于处于其内部的内部类还是可见的。）
⑵ 用内部类定义在外部类中不可访问的属性。这样就在外部类中实现了比外部类的private还要小的访问权限。
注意：内部类是一个编译时的概念，一旦编译成功，就会成为完全不同的两类。对于一个名为outer的外部类和其内部定义的名为inner的内部类。编译完成后出现outer.class和outer$inner.class两类。</pre><pre id="best-content-521589254" accuse="aContent" style="margin-top: 0px; margin-bottom: 10px; padding: 0px; font-family: arial, 'courier new', courier, 宋体, monospace; white-space: pre-wrap; word-wrap: break-word; line-height: 24px;"><span style="white-space:pre;">    </span>2.局部内部类</pre><pre id="best-content-521589254" accuse="aContent" style="margin-top: 0px; margin-bottom: 10px; padding: 0px; font-family: arial, 'courier new', courier, 宋体, monospace; white-space: pre-wrap; word-wrap: break-word; line-height: 24px;">

<span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';"><span style="white-space:pre;">    </span>在方法中定义的内部类称为局部内部类。与局部变量类似，在局部内部类前不加修饰符<font face="Times New Roman">public</font><font face="宋体">和</font><font face="Times New Roman">private</font><font face="宋体">，其范围为定义它的代码块。</font></span><span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';"></span>

<span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';"><span style="white-space:pre;">    </span>注意：局部内部类不仅可以访问外部类实例变量，还可以访问外部类的局部变量（但此时要求外部类的局部变量必须为<font face="Times New Roman">final</font><font face="宋体">）？？</font></span><span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';"></span>

<span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';"><span style="white-space:pre;">    </span>在类外不可直接生成局部内部类（保证局部内部类对外是不可见的）。</span><span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';"></span>

<span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';"><span style="white-space:pre;">    </span>要想使用局部内部类时需要生成对象，对象调用方法，在方法中才能调用其局部内部类。</span><span style="font-size: 10.5pt; font-family: Arial;"></span>
</pre><pre id="best-content-521589254" accuse="aContent" style="margin-top: 0px; margin-bottom: 10px; padding: 0px; white-space: pre-wrap; word-wrap: break-word;">    3.静态内部类</pre><pre id="best-content-521589254" accuse="aContent" style="margin-top: 0px; margin-bottom: 10px; padding: 0px; white-space: pre-wrap; word-wrap: break-word; line-height: 24px;">    用static修饰的内部类就是静态内部类，和内部类不同，其实力的创建不需要外部对象。它只能访问外部类的静态成员和静态方法，不能访问非静态成员，但却可以访问自身内部的非静态成员变量。</pre>

<p>静态内部类可以用public，protected，private修饰，静态内部类中可以定义静态成员或非静态成员。</p>
<font face="宋体">&nbsp; &nbsp;&nbsp;</font>生成（new）一个静态内部类不需要外部类成员：这是静态内部类和成员内部类的区别。静态内部类的对象可以直接生成：<br><pre id="best-content-521589254" accuse="aContent" style="margin-top: 0px; margin-bottom: 10px; padding: 0px; font-family: arial, 'courier new', courier, 宋体, monospace; white-space: pre-wrap; word-wrap: break-word; line-height: 24px;">    Outer.Inner in=new Outer.Inner()；<br>而不需要通过生成外部类对象来生成。这样实际上使静态内部类成为了一个顶级类。静态内部类不可用private来进行定义。</pre><pre id="best-content-521589254" accuse="aContent" style="margin-top: 0px; margin-bottom: 10px; padding: 0px; font-family: arial, 'courier new', courier, 宋体, monospace; white-space: pre-wrap; word-wrap: break-word;">    4.匿名内部类</pre><pre id="best-content-521589254" accuse="aContent" style="margin-top: 0px; margin-bottom: 10px; padding: 0px; font-family: arial, 'courier new', courier, 宋体, monospace; white-space: pre-wrap; word-wrap: break-word;"><pre id="best-content-521589254" accuse="aContent" style="margin-top: 0px; margin-bottom: 10px; padding: 0px; font-family: arial, 'courier new', courier, 宋体, monospace; white-space: pre-wrap; word-wrap: break-word; color: rgb(51, 51, 51);">    匿名内部类是一种特殊的局部内部类，它是通过匿名类实现接口。<br>IA被定义为接口。<br>IA I=new IA(){};<br>匿名内部类的特点：<br>1，一个类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的事先或是覆盖。其实就是一个匿名子类对象。<br>2，只是为了获得一个对象实例，不需要知道其实际类型。<br>3，类名没有意义，也就是不需要使用到。</pre><pre id="best-content-521589254" accuse="aContent" style="margin-top: 0px; margin-bottom: 10px; padding: 0px; font-family: arial, 'courier new', courier, 宋体, monospace; white-space: pre-wrap; word-wrap: break-word; color: rgb(51, 51, 51);"><span style="white-space:pre;">    </span>4， new  父类OR 接口名{}。<br></pre></pre><br><br><wbr><br><pre class="prettyprint"><br><br>interface Test //定义一个接口，接口中有方法。<br>{<br>&nbsp; &nbsp; &nbsp; &nbsp; void func();<br>}<br>class Outer<br>{<br>&nbsp; &nbsp; &nbsp; &nbsp; public void method()<br>&nbsp; &nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Test T=new Test()//new一个接口对象，然后调用接口中的func方法<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; public void func()<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {&nbsp; &nbsp; &nbsp;&nbsp;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;     }<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; };<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; T.func();//通过new的对象可以实现调用接口中的多个引用，但最终不超过三个。<br>&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp; &nbsp; &nbsp;<br>}<br>public class Demo {<br><br>&nbsp; &nbsp; &nbsp; &nbsp; public static void main(String[] args) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // TODO Auto-generated method stub<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; func(new Test()<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; public void func(){}<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; });<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; public static void func(Test in)<br>&nbsp; &nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in.func();<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>}<br></pre><span style="white-space:pre;">    </span>匿名内部类的一般好处是：是代码更加简洁，紧凑，但带来的是易读性下降。它<font color="#ff0000" style="font-family: Arial; line-height: 26px;">一般用在GUI编程中实现事件处理</font>等等。<div><span style="line-height: 23px; font-size: 10.5pt;"><span style="white-space: pre;">    </span>匿名内部类是唯一一种无构造方法类。</span><div><div><br><br><span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';">&nbsp; &nbsp; &nbsp;</span><span style="line-height: 23px; font-family: 宋体; font-size: 10.5pt;">匿名内部类在编译的时候由系统自动起名</span><font face="Times New Roman" style="line-height: 23px; font-size: 10.5pt;">Out$1.class</font><font face="宋体" style="line-height: 23px; font-family: 宋体; font-size: 10.5pt;">。</font>

<p><span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';">&nbsp; &nbsp; &nbsp;</span><span style="line-height: 23px; font-family: 宋体; font-size: 10.5pt;">如果一个对象编译时的类型是接口，那么其运行的类型为实现这个接口的类。因匿名内部类无构造方法，所以其使用范围非常的有限。 &nbsp;</span></p>
<p>一、面对对象的三大特征：封装、继承、多态。</p>
<font color="#24130c" face="Arial, Helvetica, simsun, u5b8bu4f53">    <font size="3">抽象：</font></font><font size="3">把现实中需要处理的事物通过数据的方法表达出来就是抽象。将现实的东西编程计算机的模式。</font>

<font size="3"><font face="arial, courier new, courier, 宋体, monospace">    封装：</font>把事物的数据和方法用类的方式集合起来就是封装，封装的数据和方法通过继承来实现重用。</font>

<font size="3"><font face="arial, courier new, courier, 宋体, monospace">    多态：</font>同一个方法通过方法的重载实现不同的逻辑即多态。</font>

<p>二、面对对象软件开发的大体分为，面向对象的分析，面向对象的设计，面向对象的实现。</p>
<p>分析用户的需求，从问题中抽取对象模型，细化模型，设计类，包括类的属性和类间的相互关系。同时观察是否有可以直接引用的已有的类或部件；使用Java语言，在开发中引入测试，并完善整个解决方案。</p>
<p>三、类</p>
<p>class前的修饰符分为访问控制符和非访问控制符两类。访问控制符包括public和private。非访问控制符包括abstract和final。</p>
<p>final是最终类，是不能有子类的，abstract和final不能修饰同一个类，因为抽象类本身没有具体的对象，需要派生出子类后在创建子类的对象。而最终不可能有子类。</p>
<p>创建对象的格式：类名+对象名=new 构造方法（参数）；前面是类名，后面是构造方法。</p>
<p>构造方法（构造函数）没有返回类型，也不能用void，主要完成对对象的初始化工作，一般不能直接由编程直接调用，而是用new运算符来调用。</p>
<p>如果class前面用public修饰，则默认构造方法的前面也是public修饰符。类中有static修饰的域或方法，可用类名或对象名进行访问。否则只能用对象名访问。</p>
<p><span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';"><span style="white-space:pre;">    </span>内部类的总结：</span><span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';"></span></p>
<p><span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';">&nbsp;<span style="white-space:pre;">    </span></span><span style="line-height: 23px; font-family: 宋体; font-size: 10.5pt;">内部类是指在一个外部类的内部再定义一个类。内部类作为外部类的一个成员，并且依附于外部类而存在的。</span></p>
<p><span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';">&nbsp;<span style="white-space:pre;">    </span></span><span style="line-height: 23px; font-family: 宋体; font-size: 10.5pt;">内部类同时具有成员和类的特性（特性不冲突）。&nbsp;内部类的分类：</span></p>
<p><span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';">&nbsp;<span style="white-space:pre;">    </span></span><span style="line-height: 23px; font-family: 宋体; font-size: 10.5pt;">成员内部类、</span><span style="line-height: 23px; font-family: 宋体; font-size: 10.5pt;">局部内部类、</span><span style="line-height: 23px; font-family: 宋体; font-size: 10.5pt;">静态内部类、</span><span style="line-height: 23px; font-family: 宋体; font-size: 10.5pt;">匿名内部类（图形是要用到，必须掌握）。</span></p>
<p><span style="white-space:pre;">        </span>1.成员内部类</p>
<p>成员内部类是定义在一个类中的类，他将信息更好的封装于一个类中，定义成员内部类后在使用它时可将其当成外部类的成员来使用，但若要使用内部类中的成员则需要创建内部类的实例。</p>
<p><span style="white-space:pre;">    </span>成员内部类和外部类之间的访问权限。</p>
<p>在类里面定义的类称之为内部类（Inner Class），内部类是外部类的一个成员。</p>
<p>内部类必须创建外部类对象才能使用。而创建内部类对象时必须先创建一个外部类对象，通过一个外部类对象才能创建内部类对象。</p>
<p>外部类名.内部类名&nbsp;变量名&nbsp;=&nbsp;new&nbsp;外部类名().new&nbsp;内部类名();</p>
<pre class="prettyprint">

class&nbsp;Inner{
<font color="#333333">//static&nbsp;int&nbsp;inner_i&nbsp;=100;&nbsp;//</font><font face="宋体"><font color="#333333">内部类中不允</font>许定</font>义<font color="#0000ff">静态</font><font color="#0000ff">变量</font>
<font color="#333333">int&nbsp;j=100;//</font><font face="宋体"><font color="#333333">内部类中外部类的</font><font color="#0000ff">实例变量</font></font>可以共存
int&nbsp;inner_i=1;
void&nbsp;inner_f1()

{
&nbsp;&nbsp;&nbsp;&nbsp;        System.out.println(i);//<font face="宋体">外部类的变量如果和内部类的变量没有同名的，则可以直接用变量名访问外部类的变量</font>
&nbsp;&nbsp;&nbsp;&nbsp;        System.out.println(j);//<font face="宋体">在内部类中访问内部类自己的变量直接用变量名</font>
&nbsp;&nbsp;&nbsp;    &nbsp;    System.out.println(this.j);//<font face="宋体">也可以在内部类中用</font><font face="Arial">"this.</font><font face="宋体">变量名</font><font face="Arial">"</font><font face="宋体">来访问内部类变量</font>
&nbsp;&nbsp;&nbsp;&nbsp;        //<font face="宋体">访问外部类中与内部类同名的</font>实例变量可用<font face="Arial">"</font><font face="宋体">外部类名</font><font face="Arial">.this.</font><font face="宋体">变量名</font><font face="Arial">"</font><font face="宋体">。</font>
&nbsp;&nbsp;&nbsp;&nbsp;        System.out.println(k);//<font face="宋体">外部类的变量如果和内部类的变量没有同名的，则可以直接用变量名访问外部类的变量</font>
&nbsp;&nbsp;&nbsp;&nbsp;        outer_f1();
&nbsp;&nbsp;&nbsp;&nbsp;        outer_f2();
}
}
</pre>

<p>成员内部类的优点：</p>
<pre id="best-content-521589254" accuse="aContent" style="margin-top: 0px; margin-bottom: 10px; padding: 0px; font-family: arial, 'courier new', courier, 宋体, monospace; white-space: pre-wrap; word-wrap: break-word; line-height: 24px;">    ⑴ 内部类作为外部类的成员，可以访问外部类的私有成员或属性。（即使将外部类声明为PRIVATE，但是对于处于其内部的内部类还是可见的。）
⑵ 用内部类定义在外部类中不可访问的属性。这样就在外部类中实现了比外部类的private还要小的访问权限。
注意：内部类是一个编译时的概念，一旦编译成功，就会成为完全不同的两类。对于一个名为outer的外部类和其内部定义的名为inner的内部类。编译完成后出现outer.class和outer$inner.class两类。</pre><pre id="best-content-521589254" accuse="aContent" style="margin-top: 0px; margin-bottom: 10px; padding: 0px; font-family: arial, 'courier new', courier, 宋体, monospace; white-space: pre-wrap; word-wrap: break-word; line-height: 24px;"><span style="white-space:pre;">    </span>2.局部内部类</pre><pre id="best-content-521589254" accuse="aContent" style="margin-top: 0px; margin-bottom: 10px; padding: 0px; font-family: arial, 'courier new', courier, 宋体, monospace; white-space: pre-wrap; word-wrap: break-word; line-height: 24px;">

<span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';"><span style="white-space:pre;">    </span>在方法中定义的内部类称为局部内部类。与局部变量类似，在局部内部类前不加修饰符<font face="Times New Roman">public</font><font face="宋体">和</font><font face="Times New Roman">private</font><font face="宋体">，其范围为定义它的代码块。</font></span><span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';"></span>

<span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';"><span style="white-space:pre;">    </span>注意：局部内部类不仅可以访问外部类实例变量，还可以访问外部类的局部变量（但此时要求外部类的局部变量必须为<font face="Times New Roman">final</font><font face="宋体">）？？</font></span><span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';"></span>

<span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';"><span style="white-space:pre;">    </span>在类外不可直接生成局部内部类（保证局部内部类对外是不可见的）。</span><span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';"></span>

<span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';"><span style="white-space:pre;">    </span>要想使用局部内部类时需要生成对象，对象调用方法，在方法中才能调用其局部内部类。</span><span style="font-size: 10.5pt; font-family: Arial;"></span>
</pre><pre id="best-content-521589254" accuse="aContent" style="margin-top: 0px; margin-bottom: 10px; padding: 0px; white-space: pre-wrap; word-wrap: break-word;">    3.静态内部类</pre><pre id="best-content-521589254" accuse="aContent" style="margin-top: 0px; margin-bottom: 10px; padding: 0px; white-space: pre-wrap; word-wrap: break-word; line-height: 24px;">    用static修饰的内部类就是静态内部类，和内部类不同，其实力的创建不需要外部对象。它只能访问外部类的静态成员和静态方法，不能访问非静态成员，但却可以访问自身内部的非静态成员变量。</pre>

<p>静态内部类可以用public，protected，private修饰，静态内部类中可以定义静态成员或非静态成员。</p>
<font face="宋体">&nbsp; &nbsp;&nbsp;</font>生成（new）一个静态内部类不需要外部类成员：这是静态内部类和成员内部类的区别。静态内部类的对象可以直接生成：<br><pre id="best-content-521589254" accuse="aContent" style="margin-top: 0px; margin-bottom: 10px; padding: 0px; font-family: arial, 'courier new', courier, 宋体, monospace; white-space: pre-wrap; word-wrap: break-word; line-height: 24px;">    Outer.Inner in=new Outer.Inner()；<br>而不需要通过生成外部类对象来生成。这样实际上使静态内部类成为了一个顶级类。静态内部类不可用private来进行定义。</pre><pre id="best-content-521589254" accuse="aContent" style="margin-top: 0px; margin-bottom: 10px; padding: 0px; font-family: arial, 'courier new', courier, 宋体, monospace; white-space: pre-wrap; word-wrap: break-word;">    4.匿名内部类</pre><pre id="best-content-521589254" accuse="aContent" style="margin-top: 0px; margin-bottom: 10px; padding: 0px; font-family: arial, 'courier new', courier, 宋体, monospace; white-space: pre-wrap; word-wrap: break-word;"><pre id="best-content-521589254" accuse="aContent" style="margin-top: 0px; margin-bottom: 10px; padding: 0px; font-family: arial, 'courier new', courier, 宋体, monospace; white-space: pre-wrap; word-wrap: break-word; color: rgb(51, 51, 51);">    匿名内部类是一种特殊的局部内部类，它是通过匿名类实现接口。<br>IA被定义为接口。<br>IA I=new IA(){};<br>匿名内部类的特点：<br>1，一个类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的事先或是覆盖。其实就是一个匿名子类对象。<br>2，只是为了获得一个对象实例，不需要知道其实际类型。<br>3，类名没有意义，也就是不需要使用到。</pre><pre id="best-content-521589254" accuse="aContent" style="margin-top: 0px; margin-bottom: 10px; padding: 0px; font-family: arial, 'courier new', courier, 宋体, monospace; white-space: pre-wrap; word-wrap: break-word; color: rgb(51, 51, 51);"><span style="white-space:pre;">    </span>4， new  父类OR 接口名{}。<br></pre></pre><br><br><wbr><br><pre class="prettyprint"><br><br>interface Test //定义一个接口，接口中有方法。<br>{<br>&nbsp; &nbsp; &nbsp; &nbsp; void func();<br>}<br>class Outer<br>{<br>&nbsp; &nbsp; &nbsp; &nbsp; public void method()<br>&nbsp; &nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Test T=new Test()//new一个接口对象，然后调用接口中的func方法<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; public void func()<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {&nbsp; &nbsp; &nbsp;&nbsp;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;     }<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; };<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; T.func();//通过new的对象可以实现调用接口中的多个引用，但最终不超过三个。<br>&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp; &nbsp; &nbsp;<br>}<br>public class Demo {<br><br>&nbsp; &nbsp; &nbsp; &nbsp; public static void main(String[] args) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // TODO Auto-generated method stub<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; func(new Test()<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; public void func(){}<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; });<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; public static void func(Test in)<br>&nbsp; &nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in.func();<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>}<br></pre><span style="white-space:pre;">    </span>匿名内部类的一般好处是：是代码更加简洁，紧凑，但带来的是易读性下降。它<font color="#ff0000" style="font-family: Arial; line-height: 26px;">一般用在GUI编程中实现事件处理</font>等等。<div><span style="line-height: 23px; font-size: 10.5pt;"><span style="white-space: pre;">    </span>匿名内部类是唯一一种无构造方法类。</span><div><div><br><br><span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';">&nbsp; &nbsp; &nbsp;</span><span style="line-height: 23px; font-family: 宋体; font-size: 10.5pt;">匿名内部类在编译的时候由系统自动起名</span><font face="Times New Roman" style="line-height: 23px; font-size: 10.5pt;">Out$1.class</font><font face="宋体" style="line-height: 23px; font-family: 宋体; font-size: 10.5pt;">。</font>

<p><span style="mso-spacerun:'yes'; font-size:10.5000pt; font-family:'宋体';">&nbsp; &nbsp; &nbsp;</span><span style="line-height: 23px; font-family: 宋体; font-size: 10.5pt;">如果一个对象编译时的类型是接口，那么其运行的类型为实现这个接口的类。因匿名内部类无构造方法，所以其使用范围非常的有限。 &nbsp;</span></p>
</div></div></div></div></div></div>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://source.wait.im/QNbCS5A.jpg"
               alt="thinkloki" />
          <p class="site-author-name" itemprop="name">thinkloki</p>
          <p class="site-description motion-element" itemprop="description">在路上</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">thinkloki</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  

  




  
  

  

  

  

  


</body>
</html>
